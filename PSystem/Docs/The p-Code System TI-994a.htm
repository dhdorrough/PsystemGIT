<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- saved from url=(0055)http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Untitled Document</title>
  
  <meta name="GENERATOR" content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body bgcolor="#ffffff">
<h1 align="center"><a href="http://www.nouspikel.com/ti99/titechpages.htm"><img src="./The p-Code Systen TI-994a_files/logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;" title="Back to main index" alt=""></a></h1>
<h1>The p-code system</h1>
<h4>Introduction</h4>
<p>The idea behind p-code is very elegant: it is an "ideal" assembly
language to be run on a virtual microprocessor. Concretely, it means
that
it requires an interpreter, the p-machine emulator or PME, to emulate
this
virtual microprocessor. The big advantage is that you can write p-code
"assembly" programs (or compile higher languages into p-code)
and run them on many different machines. The language was optimized so
as to be easy to emulate and to run smoothly on any machine. Apart from
the TI-99/4A there were emulators written for the Z80, Z8000, 6502,
6509,
Motorola 6800 and 68000 (Apple computers), HP-87, PDP-11, Intel 8080
and
8086 (PCs) , and GA440 microprocessors (and what on earth is the
latter?).</p>
<p>This article is split in two pages. The present one discusses the
p-system
operation, another describes the TI-99/4A <a href="http://www.unige.ch/medecine/nouspikel/ti99/pcode.htm">p-code
card</a>
and accompanying software.</p>
<p>p-code is a fully relocatable language: all addressing is done
relative
to the current instruction or to the beginning of a segment. This
allows
for a very flexible operating system, that can load program segments in
memory, move them as needed, reload them from disk at a different
location,
etc. The main drawback is that it is slower than real assembly language
since it is interpreted. On the other hand, it is fairly compact and
lends
itself easily to compilation of high-level languages (mainly Pascal).</p>
<p>A typical p-system implementation consists in several layers:</p>
<li>The PME (pseudo-machine emulator) translates p-code into assembly,
handles the stack and registers, etc. All parts of the PME that are not
dedicated to directly emulate p-code form the RSP, or run-time service
package. The section of the RSP that communicates with the BIOS is
called
RSP/IO.</li>
<li>The BIOS (Basic Input/Output Subsystem) allows for interfacing the
PME with computer-specific hardware. Generally, this will be the ROM
BIOS
(on the TI-99/4A: the cards DSRs) with a thin wrapping layer to
implement
a few niceties specific to the p-system. </li>
<li>The operating system loads p-code programs, manages segments and
the
memory heap, deals with run-time errors, etc.</li>
<li>Programs compiled in p-code run whithin the operating system. These
can be system-level utilities, such as an Editor or a Compiler, or
user-written
programs. It is also possible to run 9900 assembly-language programs
within
the p-code system.</li>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#p-machine">The p-machine emulator (PME)<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#RSP">Run-time service package (RSP)<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#BIOS">BIOS<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#OS">Operating system<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#File_format">File formats</a></p>
<h2><br>
<a name="p-machine"></a>The p-machine emulator</h2>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#registers">Registers<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#stack">Stack<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#proc%20nesting">Procedure nesting<br>
</a><b>Instructions<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#calls">_Calls<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#data%20access">_Data access<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#stack%20manip">_Stack manipulation<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#arithm-logic">_Arithmetic &amp; logic<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#comparisons">_Comparisons<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#flow%20control">_Flow control<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#strings">_Arrays and Strings<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#sets">_Sets<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#multitasking">_Multitasking<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#misc%20instructions">_Miscellaneous<br>
</a><b>Standard procedures<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Standard%20procedures">_Summary<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Unit-related">_Unit-related<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#string-related">_String-related<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#code%20pool-related">_Code pool management<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#concurency-related">_Concurency procedures<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#misc%20procedures">_Miscellaneous procedures<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#compiler-related">_Compiler usage<br>
</a><b>Faults and execution errors<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Faults&amp;errors">_Faults<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Execution%20errors">_Execution errors<br>
</a><b>Data representation<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#data%20representation">_Words (byte sex)<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Long%20integers">_Long integers<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#real%20numbers">_Real numbers</a></p>
<p><br>
</p>
<h4><a name="registers"></a>Registers</h4>
<p>Every microprocessor contains registers, i.e. a small amount of
on-chip
memory. These can be general purpose or dedicated registers. For
instance,
the PC register on a TMS9900 microprocessor points to the next
instruction
to be executed. By contrast, general-purpose registers can be used by
the
programmer for any purpose he fancies.</p>
<p>The p-machine emulates only special-purpose registers. To perform
any
calculation you must use the memory stack:. push a number on the stack,
push another number, perform an addition, and pop the result from the
stack.
This is a bit of a pain, unless you a are a fan of Hewlett-Packard
calculators
and their reverse-polish notation. On the other hand, it sure makes the
p-machine easy to implement on any kind of system.</p>
<p>The dedicated registers are implemented in the host system memory
and
hold various pointers and data required for proper operation of the
p-machine.
They are normally used only by the p-machine emulator itself, however
there
are two p-codes that let you fool around with them: LPR and SPR.</p>
<p><b>IPC<br>
</b>This register contains a pointer to the next p-code to be executed.</p>
<p><b>SP<br>
</b>Points to the word at the top of the stack. This pointer changes
after
execution of almost any p-code whenever something is push on, or poped
off the stack.</p>
<p><b>CURPROC<br>
</b>This register contains the number of the current procedure (0-255)
in the current segment.</p>
<p><b>MP<br>
</b>Contains a pointer to the current activation record (<a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#MSCW">MSCW</a>).
This is required to access local variables that are allocated on the
stack
when a procedure is called. Global variables are accessed via BASE, or
indirectly via EREC.</p>
<p><b>CURTASK<br>
</b>Points to the current task information block (<a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#TIB">TIB</a>).</p>
<p><b>READYQ<br>
</b>Points to the TIB at the top of the list of tasks ready to run.</p>
<p><b>EREC<br>
</b>Points to the current environment record (<a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#E_Rec">E_Rec</a>),
which changes every time a call is made to a procedure in a different
segment.
The E_Rec contains many usefull values that may also be copied into a
dedicated
register. This makes the implementation of such registers optional
since
a given p-machine emulator (a.k.a. PME) can access them indirecly via
EREC.</p>
<p><b>EVEC<br>
</b>Points to the current environment vectors. This is an exemple of a
redundant register, since its content can be found in the E_Rec.
However,
it should be implemented on any PME.</p>
<p><b>IORESULT<br>
</b>Contains the completion code resulting from the last I/O operation
(0-255). This is the only register that can be accessed direcly by the
system, as it is located in the SYSCOM memory area.</p>
<p><b>BASE<br>
</b>Contains a pointer to the global variables. This register is
optional
since its value can be found via EREC.</p>
<p><b>SIB<br>
</b>Contains a pointer to the current segment information block.
Optional,
since such a pointer can be found in the E_Rec.</p>
<p><b>CURSEG<br>
</b>Points to the current segment in memory. Optional since such a
pointer
is found in the SIB.</p>
<h4><br>
<a name="stack"></a>Stack</h4>
<p>As the p-machine virtual processor does not comprise any
general-purpose
register, all data manipulation must be performed on the stack. This is
why basically any p-code affects the stack. For instance, to add two
numbers
you would push each of them on the stack (e.g. with LCB, load constant
byte), add them (with the ADI p-code), and retrieve the result from the
stack (here, using the SRO p-code to store it in global variable # 5):</p>
<pre>                                 <u>      </u> &lt;-SP<br>                 <u>      </u> &lt;-SP    |<u>  34  </u>|         <u>      </u> &lt;-SP     <br> <u>      </u> &lt;-SP    |<u>  10  </u>|        |<u>  10  </u>|        |<u>  44  </u>|         <u>      </u> &lt;-SP<br>|//////|        |//////|        |//////|        |//////|        |//////|<br>         LCB 10          LCB 34           ADI            SRO 5</pre>
<p>The stack is used by the p-machine to implement local variables when
a procedure is entered. The caller must also place the procedure
parameters
on the stack prior to the call, and reserve room for the return value
if
the procedure is a function.</p>
<h4><br>
<a name="proc nesting"></a>Procedure nesting</h4>
<p>From the structure of the p-code language, you can tell it was
invented
by Pascal programmers: provision is made for procedures that are local
to other procedures (i.e. nested into them) and a lot of p-codes are
devoted
to access these procedures or their variables. Let me illustrate this
with
an exemple:</p>
<pre>segment SEG1</pre>
<pre>  int VARG1</pre>
<pre>  proc GLOB1<br>       proc LOC1<br>            int VAR1<br>       end-of-LOC1</pre>
<pre>       proc LOC2<br>       end-of-LOC2<br>  end-of-GLOB1</pre>
<pre>  proc GLOB2<br>       proc LOC3<br>            int VAR3<br>            proc LOC31<br>                 int VAR31<br>                 Proc LOC311<br>                 end-of-LOC311<br>            <font color="#ff0000">&lt;&lt;you are here&gt;&gt;<br></font>            end-of-LOC31<br>       end-of-LOC3</pre>
<pre>       proc LOC4<br>            int VAR4<br>       end-of-LOC4<br>  end-of-GLOB2</pre>
<pre>end-of-SEG1</pre>
<p>In this example, GLOB1 and GLOB2 are global procedures, VARG1 is a
global
variable. LOC1 and LOC2 are procedures local to GLOB1, whereas LOC3 and
LOC4 are local to GLOB2. LOC31 is a procedure local to LOC3 and LOC311
is local to LOC31. Note that at each level, there can be variables (in
this case, integers) local to the procedure.</p>
<p>Assume the program has reached the point indicated by &lt;&lt;you
are
here&gt;&gt;, in procedure LOC31. From there, you could:</p>
<ul>
  <li>Call the procedure LOC311, which is local to the current
procedure
(i.e. LOC31): use the CLP p-code (call local procedure).</li>
  <li>Call global procedure GLOB1 (or GLOB2: recursive call) with the
p-code
CGP (call global procedure).</li>
  <li>Call a procedure by walking up the nesting structure with the CIP
p-code
(call intermediary procedure). CIP 0 is the same as CLP. CIP 1 calls a
procedure that is 1 level above the current one, i.e. its lexical
parent
LOC3, CIP 2 calls the procedure two levels above, etc (in our case, CIP
2 calls GLOB2, and is thus equivalent to CGP).</li>
  <li>In Pascal, you cannot call LOC1 because it is local to GLOB1,
which
is not a parent of the current procedure. In p-code however, you could
do it with any of the above calls since the procedure is called by
number.
But the <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#MSCW">MSCW</a> will contain a bad static link and
you
are up for trouble if you try accessing local or intermediary variables
from inside the called procedure..</li>
  <li>You could also access procedures located in another segment, with
p-codes
CXG, CXL, and CXI. (Again, the last two would be illegal in Pascal).</li>
</ul>
<p>Similarly you can access the following variables:</p>
<ul>
  <li>VAR31 wich is local to the current procedure, by using "local"
p-codes such as LLA, LDL, STL, etc.</li>
  <li>VARG1 with global variable p-codes (LAO, LDO, SRO, etc).</li>
  <li>VAR3 with "intermediary" p-codes, that walk up the nesting
levels: LDA, LOD, SOD. For VAR3 you would use LOD 1,1 to step up one
level.</li>
  <li>You can't access VAR4 from where you are, because it is local to
LOC4
which is not a parent of the current procedure.</li>
  <li>You could also access global variables located in another
segment,
but not local variables.</li>
</ul>
<p>OK, I hope you got the picture, let's procede with p-code
instructions.</p>
<h3><br>
<a name="calls"></a>Instructions</h3>
<p>A p-code (pseudo-opcode) is always 1 byte long, but it can be
followed
by one or more arguments. There are several types of arguments:</p>
<ul>
  <li>&lt;UB&gt; Unsigned byte. A number between 0 and +256</li>
  <li>&lt;SB&gt; Signed byte. A number between -128 and +127. Negative
numbers
are expressed as two's complement (&gt;FF = -1, &gt;FE = -2... &gt;80 =
-128).</li>
  <li>&lt;DB&gt; Don't care byte. A number between 0 and +127. The most
significant
bit is always 0.</li>
  <li>&lt;W&gt; Word. This is a two-byte parameter that contains a
number
between -32768 and +32767. Negative numbers are in two's complement
representation
(&gt;FFFF = -1, etc)..</li>
  <li>&lt;B&gt; Big. This parameter can be either one or two bytes
long.
With one byte, it represents a number from 0 to +127 (i.e. the leftmost
bit is 0). With two bytes, it represents a number between 0 and +32768.
So as to distinguish the two possibilities, the leftmost bit is set to
indicate a two-byte parameter (e.g. &gt;8101 is 257).</li>
</ul>
<p>For your convenience I have arranged the p-codes in several families:</p>
<h4>Calls</h4>
<p>These p-codes are used to call a procedure. Before executing such an
instruction, you should prepare the stack with the adequate parameters,
as illustrated below. It is the responsability of the called procedure
to pop each parameter from the stack and to leave the adequate result
on
it (if any). Note the practice of reserving space for the result before
the first parameter. This generally will be one or two words, but may
be
upto four words, depending of the format used for real numbers.</p>
<pre>                                    <u>       </u> &lt;          <u>       </u> &lt; <br>                                   |<u> MSCW  </u>|          |<u> MSCW  </u>|<br>                 <u>       </u> &lt;         |<u> data  </u>|          |<u> data  </u>|<br>                |<u> param </u>|          |<u> param </u>|   ...    |<u> param </u>|         <u>       </u> &lt;<br> <u>      </u>  &lt; ...  |<u>   0   </u>|          |<u>   0   </u>|          |<u> result</u>|        |<u> result<i>|</i></u> <br>|///////|       |///////|          |///////|          |///////|        |///////|<br>         prepare          CXG 2,31         called proc           RPU            caller can<br>         for call         calls a proc     does its job         return          use result</pre>
<p>Within the program stream, each procedure entry point consists of
two
data words that immediately precede the first p-code to be executed.
These
are <b>exit_ic</b> that points to some (optional) exit code to be
execute
upon returning from the procedure and <b>data_size</b> that indicated
how
many bytes must be reserve on stack to store the procedure local
variables.
This space is marked as "data" in the above illustration.</p>
<p><a name="MSCW"></a>You may have wondered what MSCW stands for.
That's
"Mark Stack Control Word", also known as "activation record".
A mark stack consists in five words:</p>
<p>MSSTAT<br>
MSDYN<br>
MSIPC<br>
MSENV<br>
MSPROC</p>
<p>MSPROC hold the procedure number of the caller, MSIPC is a
segment-relative
pointer to the point of call, MSENV contains a pointer to the E_Rec of
the caller (i.e. its segment). MSDYN points at the MSCW of the caller
and
MSSTAT points at the MSCW of the lexical parent (i.e. the procedure
into
which the current procedure is nested, if any). The latter will be
needed
to access variables that are not local to the procedure.</p>
<p>When a call is performed, the PME allocates space on the stack and
initialises
the MSCW. It sets IPC to point at the first p-code in the procedure,
and
update the CURPROC, EREC and EVEC registers. If there aren't 40 words
free
on the stack after data and MSCW have been reserved, a stack fault is
issued
that will be handled by the system.</p>
<p>There are several p-code calls, depending where the procedure is
located:</p>
<p><a name="CGP"></a><b>CGP &lt;UB&gt; <br>
</b>Call Global Procedure. The procedure number in passed with UB, an
unsigned
data byte included in the code stream, just after the CGP p-code itself.</p>
<p><a name="CLP"></a><b>CLP &lt;UB&gt;<br>
</b>Call Local Procedure, i.e. a procedure nested into the calling
procedure.
Again, UB is the procedure number and follows CLP in memory.</p>
<p><a name="CIP"></a><b>CIP &lt;DB&gt;&lt;UB&gt;<br>
</b>Call Intermediary Procedure, i.e. a procedure which is a lexical
parent
of the current one. DB is a value from 1 to 127 that indicates how many
nesting levels should be walked back to the target procedure, from MSCW
to MSCW. UB is the procedure number.</p>
<p><a name="SCIP"></a><b>SCIPn &lt;UB&gt; <br>
</b>Where n is 1 or 2. This is a short form of CIP, that calls
procedures
&lt;UB&gt;, and sets the MSSTAT field of MSCW to the lexical parent
(for
SCIP1) or grandparent (for SCIP2) of the calling procedure. It is
shorter
than CIP since the nesting level is part of the opcode, so it uses two
bytes instead of three.</p>
<p><a name="CXG"></a><b>CXG &lt;UB1&gt;,&lt;UB2&gt;<br>
</b>Call eXternal Global procedure, same as CGP but targets another
segment.
UB1 is the segment number. If it's not in memory yet, a segment fault
is
issued so that the system has a chance to load the segment. UB2 is the
procedure number.</p>
<p><a name="SCXG"></a><b>SCXGn &lt;UB&gt;<br>
</b>Where n is in the range 1 to 8. This is a short form of CXG that
calls
global procedure UB in the segment indicated by n.</p>
<p><a name="CXL"></a><b>CXL &lt;UB1&gt;,&lt;UB2&gt;<br>
</b>Call eXternal Local procedure. UB1 is the segment number, UB2 the
procedure
number.</p>
<p><a name="CXI"></a><b>CXI &lt;UB1&gt;,&lt;DB&gt;,&lt;UB2&gt;<br>
</b>Call eXternal Intermediary procedure. UB1 is the segment number,
UB2
the procedure number. DB is the number of nesting levels to be walked
backwards
through the MSCWs to find the procedure.</p>
<p><a name="CFP"></a><b>CFP &lt;UB&gt;<br>
</b>Call Formal Procedure. This allows you to code a procedure call "on
the fly" rather than including it in the code stream. Three data words
must be placed on the stack prior to execution:</p>
<pre> <u>         </u> <br>|<u>proc-num </u>|<br>|<u>e-rec-ptr</u>|<br>|<u>stat-link</u>|<br>|/////////|</pre>
<p>Proc_num is the number of the procedure to be called, it will be
placed
in the CURPROC register. <br>
E_Rec_Ptr points to the environment record of the segment to be used.<br>
Stat_link is the value to be placed in the MSSTAT field of the MSCW. </p>
<p>In other words, procedure &lt;proc_num&gt; in the segement indicated
by &lt;e_rec_ptr&gt; is called. I'm not sure what's the use of
&lt;UB&gt;,
it may be a typo in the manual...</p>
<p><a name="LSL"></a><b>LSL &lt;DB&gt;</b></p>
<p>Load Static Link. DB indicates the number of static links to travel.
A pointer to the MSCW that is DB static links above the current one
(1=parent,
2=grandparent, etc) is placed on the stack. This comes handy to prepare
the stack for a CFP instruction.</p>
<p><a name="RPU"></a><b>RPU<br>
</b>Return from ProcedUre. This is the instruction used to return from
any procedure call. The various fields in the MSCW are used to restore
the caller's environment: </p>
<ul>
  <li>The E_Rec is restored from the value saved in MSENV (which may
cause
a segment fault if the segment isn't present any more and must be
reloaded).
  </li>
  <li>MP is restored from MSDYN.</li>
  <li>CURPROC&nbsp; is restored from MSPROC. </li>
  <li>Finally IPC can either be restored from MSIPC or set to the
exit_ic
value found upstream of the procedure in the code stream. Which of the
two is performed depends whether MSPROC&nbsp;is positive or negative:
if
it's positive MSIPC&nbsp;is used, if it's negative exit_ic is used (in
any case CURPROC will be positive). Thus you can cause the exit code to
be executed by negating the MSPROC word in the MSCW: it's the first
word
after your local data.<br>
  </li>
</ul>
<h4><br>
<a name="data access"></a>Data access</h4>
<p>Just as you can call global, local and intermediary procedures, you
can access global, local or intermediary-level variables. You can also
access global variables in another segment. For constants, you can
either
access constants located in the constant pool of the current segment or
include a constant value whithin the code stream. </p>
<table border="1">
  <tbody>
    <tr>
      <td><br>
      </td>
      <th>Global</th>
      <th>Local</th>
      <th>Intermediary</th>
      <th>Extended</th>
      <th>Constant</th>
    </tr>
    <tr>
      <th>Load address</th>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LAO">LAO</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LLA">LLA</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SLLA">SLLA</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDA">LDA</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LAE">LAE</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LCO">LCO</a></td>
    </tr>
    <tr>
      <th>Load value</th>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDO">LDO</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SLDO">SLDO</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDL">LDL</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SLDL">SLDL</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LOD">LOD</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SLOD">SLOD</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDE">LDE</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDC">LDC</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDCRL">LDCRL</a> <br>
      <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDCB">LDCB</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDCI">LDCI</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SLDC">SLDC</a>,
      <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#LDCN">LDCN</a></td>
    </tr>
    <tr>
      <th>Store value</th>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SRO">SRO</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#STL">STL</a>, <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SSTL">SSTL</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#STR">STR</a></td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#STE">STE</a></td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
<p>Let's start with global variables:</p>
<p><a name="LAO"></a><b>LAO &lt;B&gt;<br>
</b>Load glObal Address. Places the address of the global variable with
offset B (in the global MSCW pointed by BASE) on the stack.</p>
<p><a name="LDO"></a><b>LDO &lt;B&gt;<br>
</b>LoaD glObal. Places the value of the global variable B on the stack.</p>
<p><a name="SLDO"></a><b>SLDOn<br>
</b>Where n is a number from 1 to 16. This is a short form of LDO, used
to load one of the first 16 global variable. The number of the variable
is part of the p-code, and thus does not require and extra byte (or
two)
in the code stream.</p>
<p><a name="SRO"></a><b>SRO &lt;B&gt;<br>
</b>StoRe glObal. Stores the word currently on the stack into global
variable
B.<br>
</p>
<p><br>
Now let's see local variables. They are created on stack when a
procedure
is entered, between the calling parameters and the MSCW. They are
specifed
by their offset with respect to the MSCW.</p>
<p><a name="LLA"></a><b>LLA &lt;B&gt;<br>
</b>Load Local Address. Places on the stack the address of the local
variable
with offset B in the data area of the current procedure (i.e. on the
stack,
below the MSCW). </p>
<p><a name="SLLA"></a><b>SLLAn<br>
</b>Where n is a number from 1 to 8. This is a short form of LLA, that
loads the address of the first eight local variables. It is shorter
than
LLA because the number of the variable is part of the p-code instead of
requiring an extra byte (or two).</p>
<p><a name="LDL"></a><b>LDL &lt;B&gt;<br>
</b>LoaD Local. Places on the stack the value of the local variable
with
offset B below the current MSCW.</p>
<p><a name="SLDL"></a><b>SLDLn<br>
</b>Where n is a number from 1 to 16. This is a short form of LDL, that
loads one of the first sixteen local variables.</p>
<p><a name="STL"></a><b>STL &lt;B&gt;<br>
</b>STore Local. The word at the top of the stack is poped and placed
into
the variable with offset &lt;B&gt; below the current MSCW.</p>
<p><a name="SSTL"></a><b>SSTLn<br>
</b>Where n is a number from 1 to 8. Short form of STL where the number
of the local variable to modify is part of the p-code. <br>
</p>
<p><br>
Intermediary variables are local to a ancestor of the current procedure
and are therefore present on stack, below the MSCW of the ancestor.
They
are accessed by walking up the chain of MSSTAT words in the MSCW of the
respective procedures.</p>
<p><a name="LDA"></a><b>LDA &lt;DB&gt;,&lt;B&gt;<br>
</b>Load intermeDiary Address. Places on the stack the address of
variable
B below the MSCW found &lt;DB&gt; levels above the current one. DB=0
means
the current procedure (i.e. local variables), DB=1 means the lexical
parent
in which the current procedure is nested, etc</p>
<p><a name="LOD"></a><b>LOD &lt;DB&gt;,&lt;B&gt;<br>
</b>LOad intermeDiate. Places on the stack the value of the variable
with
offset B below the MSCW found &lt;DB&gt; levels above the current one .</p>
<p><a name="SLOD"></a><b>SLODn &lt;B&gt;<br>
</b>Where n is 1 or 2. Short form of LOD to access variables in the
lexical
parent (SLOD1) or grandparent (SLOD2) of the current procedure.</p>
<p><a name="STR"></a><b>STR &lt;DB&gt;,&lt;B&gt;<br>
</b>SToRe intermediate. DB indicates the number of static links to
travel
to find the proper MSCW (0=current, 1=parent, etc). The variable with
offset
&lt;B&gt; in the target procedure will receive the word currently on
top
of the stack.<br>
</p>
<p><br>
It is also possible to access global variables in another segment.</p>
<p><a name="LAE"></a><b>LAE &lt;UB&gt;,&lt;B&gt;<br>
</b>Load Address Extended. The address of the global variable with
offset
B in segment UB is placed on the stack.</p>
<p><a name="LDE"></a><b>LDE &lt;UB&gt;,&lt;B&gt;<br>
</b>LoaD Extended. Places the value of global variable B in segment UB
on the stack.</p>
<p><a name="STE"></a><b>STE<br>
</b>STore Extended. Pops the word on top of the stack and stores it in
global variable B in segment UB.<br>
</p>
<p><br>
Constant values may be placed in a dedicated memory area called the
code
pool, or included within the p-code stream.</p>
<p><a name="LCO"></a><b>LCO &lt;B&gt;<br>
</b>Load Constant Offset. B is the offset of a constant in the constant
pool of the current segment (i.e. the constant "index"). The
instructions places the address of this constant on the stack, in the
form
of a segment-relative offset.</p>
<p><a name="LDC"></a><b>LDC &lt;UB1&gt;,&lt;B&gt;,&lt;UB2&gt;<br>
</b>LoaD Constant. B is the offset of a constant in the constant pool
of
the current segment. The instructions pushes UB2 words on the stack,
starting
from this offset. UB1 is the mode, if it is 2 and the current segment
is
of the opposite byte sex than the host processor, bytes will be swapped
upon copy.</p>
<p><a name="LDCRL"></a><b>LDCRL &lt;B&gt;<br>
</b>LoaD Constant ReaL. The real constant at offset B in the real
sub-pool
(a specialized portion of the constant pool) is loaded on stack.
Depending
on the format used by the code file, a real number uses up two or four
words on the stack.</p>
<p>With the following p-codes, the constant is part of the code:</p>
<p><a name="LDCB"></a><b>LDCB &lt;UB&gt;<br>
</b>LoaD Constant Byte. Places the value &lt;UB&gt; on stack.</p>
<p><a name="LDCI"></a><b>LDCI &lt;W&gt;<br>
</b>LoaD Constant Integer. Places the value W on stack.</p>
<p><a name="LDCN"></a><b>LDCN<br>
</b>LoaD Constant Nil. Places the "nil" value on the stack. The
value depends on the microprocessor running the PME. With the TI-99/4A
it is &gt;0000.</p>
<p><a name="SLDC"></a><b>SLDCn<br>
</b>Short LoaD Constant. Where n is a number from 0 to 31. These
p-codes
place a number from 0 (SLDC0) to 31 (SLDC31) on the stack.</p>
<h4><br>
<a name="stack manip"></a>Stack manipulation</h4>
<p>Now that we have placed variables on the stack, we can manipulate it.</p>
<p><a name="DUP1"></a><b>DUP1<br>
</b>Duplicate 1 word. Pushes on top of the stack an extra copy of the
word
at top of stack.</p>
<p><a name="DUPR"></a><b>DUPR<br>
</b>Duplicate real. Make an extra copy of the real at top of stack (two
or four words depending on the real number format).</p>
<p><a name="SWAP"></a><b>SWAP<br>
</b>Swaps the two words at the top of the stack.</p>
<h5><br>
Real &lt;--&gt; integer conversions:</h5>
<p><a name="FLT"></a><b>FLT<br>
</b>FLoaT. Replaces the integer at top of stack by the corresponding
real
number.</p>
<p><a name="TNC"></a><b>TNC<br>
</b>TruNCate real. Assuming the stack contains a real number, it will
be
replaced with the corresponding integer after truncation of the decimal
part. If the real is not in the range -32768 to 32767 a floating point
execution error is issued (and that's bad news!).</p>
<p><a name="RND"></a><b>RND<br>
</b>RouND. Replaces the real number on top of the stack with the
corresponding
integer rounded to the nearest integer. If the number is not in the
range
-32768 to +32767, an execution error occurs.</p>
<h5><br>
Address &lt;--&gt; value conversions.</h5>
<p><a name="LDB"></a><b>LDB<br>
</b>LoaD Byte. Assuming a byte-pointer is at the top of the stack, it
is
replaced with the value of this byte (in the form of a word whose high
byte is &gt;00).</p>
<p><a name="STB]"></a><b>STB<br>
</b>STore Byte. Assuming the stack contains a byte pointer topped with
a byte value (i.e. a word with value 0 to 255), this value is assigned
to the pointed byte. The stack is cleared afterwards.</p>
<p><a name="IND"></a><b>IND &lt;B&gt;<br>
</b>INDex. Assuming the word at top of stack is the address of a
record,
it is replaced by the value found at this address plus offset
&lt;B&gt;.
IND 0 is thus the equivalent of LDB for words.</p>
<p><a name="SIND"></a><b>SINDn<br>
</b>Where n is a number from 0 to 7. This is a short from of IND, used
to access the first 8 words of a record.</p>
<p><a name="INC"></a><b>INC &lt;B&gt;<br>
</b>INCrement. Assuming the word on top of the stack is an address, it
is indexed by B (i.e. B is added to it).</p>
<p><a name="STO"></a><b>STO<br>
</b>STOre. Assuming the stack contains an address topped with an
integer
value, this value is stored at the indicated address. Both are
subsequently
removed from the stack.</p>
<p><a name="LDRL"></a><b>LDRL<br>
</b>LoaD Real. Assuming the top of the stack contains the address of a
real number, it is replaced with the value found at this address (two
or
four words depending on the real number format).</p>
<p><a name="STRL"></a><b>STRL<br>
</b>STore ReaL. Assuming the stack contains an address topped with a
real
number, this number will be stored at the indicated address. Both the
number
and the address are then removed from the stack.</p>
<p><a name="LDM"></a><b>LDM &lt;UB&gt;<br>
</b>LoaD Multiple. Assuming the stack contains an address, it is
replaced
with a block of UB words found at this address. A stack fault is issued
if less than UB+20 words are available on the stack.</p>
<p><a name="STM"></a><b>STM &lt;UB&gt;<br>
</b>STore Multiple. Assuming the stack contains an address, topped with
a block of UB words, these words will be stored at the indicated
address.
The stack pointer is then adjusted to remove the block and the address
from the stack.</p>
<p><a name="LDP"></a><b>LDP<br>
</b>LoaD Packed. Assuming a packed-field pointer is at the top of the
stack,
it is replaced with the value of the field it points at. This value
will
be in the form of a right-justified word, padded on the left with "0"
bits.</p>
<p><a name="STP"></a><b>STP<br>
</b>STore Packed. Assuming the stack contains a packed-field pointer,
topped
with an integer value, the value it stored into the pointed field.
Value
and pointer are removed from the stack.</p>
<p><a name="MOV"></a><b>MOV &lt;UB&gt;,&lt;B&gt;</b></p>
<p>MOVe. The word on top of the stack is the address of a source block
of words. The word below it is the address of the destination. B is the
number of words to be copied from the source to the destination. If
UB=0
the source is a variable, otherwise it is a constant and the word on
top
of the stack is its offset in the current segment. If UB=2 and the
current
segment has the opposite byte sex from the host processor, bytes will
be
swapped upon copy.</p>
<h4><br>
<a name="arithm-logic"></a>Arithmetic and logic instructions</h4>
<p>OK, now that we have data placed on stack, we can perform math on
them.
Let's begin with integers:</p>
<p><a name="ABI"></a><b>ABI<br>
</b>ABsolute value Integer. Takes the absolute value of the integer
found
on top of the stack. Exception: -32768 stays as it is (since +32768
cannot
be represented with 16 bits).</p>
<p><a name="NGI"></a><b>NGI<br>
</b>NeGate Integer. Negates the integer on top of the stack. -32768
remains
unchanged.</p>
<p><a name="DECI"></a><b>DECI<br>
</b>DECrement Integer. Decrements by one the integer on top of the
stack.
Wraps around from -32768 to +32767.</p>
<p><a name="INCI"></a><b>INCI<br>
</b>INCrement Integer. Increments by one the integer on top of the
stack.
Wraps around from +32767 to -32768.</p>
<p><a name="ADI"></a><b>ADI<br>
</b>ADd Integer. Adds up the two integers on top of the stack and
replaces
them with the result. Overflow and underflow wrap around to the
opposite
sign.</p>
<p><a name="SBI"></a><b>SBI<br>
</b>SuBstract Integer. Substract the integer on top of the stack from
the
integer below it. Overflow and underflow wrap around.</p>
<p><a name="MPI"></a><b>MPI<br>
</b>MultiPly Integer. Multiply the two integers on the top of the stack
and replace them with the result. The result is calculated as a 32-bit
number, but only the least significant 16 bits will appear on stack
(i.e.
overflows result in crazy values).</p>
<p><a name="DVI"></a><b>DVI<br>
</b>DiVide Integer. Divides the second integer from the top by the
integer
on the top of the stack, and replaces them with the result. Truncation
is always toward zero. Divisions by zero cause an execution error.</p>
<p><a name="MODI"></a><b>MODI<br>
</b>MODulo Integer. Adds or substract the word on top of the stack from
the word below it until the remainder is in the desired range. Replaces
both integers with the remainder. If the top word is zero an execution
error occurs, if it is negative the result is undefined but no error
occurs.</p>
<p><br>
And now, let's do the same for real numbers. Remember, depending on the
adopted format, a real number can be two or four words long:</p>
<p><a name="ABR"></a><b>ABR<br>
</b>ABsolute Real. The real number on top of the stack is replaced with
it absolute value.</p>
<p><a name="NGR"></a><b>NGR<br>
</b>NeGate Real. Negates the real number on top of the stack.</p>
<p><a name="ADR"></a><b>ADR<br>
</b>ADd Real. Adds the two reals on top of stack and replaces them with
the result. Undeflow defaults to zero, overflow causes an execution
error.</p>
<p><a name="SBR"></a><b>SBR<br>
</b>SuBstract Real. Substract the real number on top of the stack from
the real number under it and replaces them with the result. Undeflow
defaults
to zero, overflow causes an execution error.</p>
<p><a name="MPR"></a><b>MPR<br>
</b>MultiPly Real. Multiplies the top reals on top of the stack and
replaces
them with the result. Undeflow defaults to zero, overflow causes an
execution
error.</p>
<p><a name="DVR"></a><b>DVR<br>
</b>DiVide Real. Divides the second real from the top by the real above
it and replaces them with the result. Undeflow defaults to zero,
overflow
causes an execution error.</p>
<p><br>
Note that there is not p-code for modulo real. Let's conclude this
section
with a few logical operations:</p>
<p><a name="LNOT"></a><b>LNOT<br>
</b>Inverts the word on top of the stack, bitwise (i.e. "0" bits
are replaced with "1" and conversely).</p>
<p><a name="BNOT"></a><b>BNOT<br>
</b>Same as LNOT, but only the least significant bit is kept. Thus the
result will always be &gt;0000 (false) or &gt;0001 (true) no matter how
many bits were set in the word.</p>
<p><a name="LAND"></a><b>LAND<br>
</b>The two words on top of the stack are "anded" bitwise and
replaced with the result. Bitwise: 0 and 0 = 0, 0 and 1 = 0, 1 and 0 =
0, 1 and 1 = 1.</p>
<p><a name="LOR"></a><b>LOR<br>
</b>The two words on top of the stack are "ored" bitwised and
replaced with the result. Bitwise: 0 or 0 = 0, 0 or 1 = 1, 1 or 0 = 1,
1 or 1 = 1.</p>
<p>NB. Sadly enough, there is no p-code for XOR operations (exclusive
or).</p>
<h4><br>
<a name="comparisons"></a>Comparisons</h4>
<p>The following p-code are used to make comparison between values
placed
on the stack. The result of the comparison is generally a boolean word
(i.e. &gt;0001 for "true" and &gt;0000 for "false) that
will <b>replace </b>these values on the stack. The boolean can
subsequently
be used for a conditional jump (see next section).</p>
<p><a name="EQUI"></a><b>EQUI<br>
</b>EQUal Integer. Places "true" on the stack if the two integers
on top of the stack are identical, "false" otherwise.</p>
<p><a name="NEQI"></a><b>NEQI<br>
</b>Not EQual Integer. Places "false" on the stack if the two
integers on top of the stack are identical, "true" otherwise.</p>
<p><a name="GEQI"></a><b>GEQI<br>
</b>Greater or EQual Integer. Places "true" on the stack if the
second integer from the top of the stack is greater than or equal to
the
integer on top of the stack. This is a signed comparison, i.e. &gt;8002
(a negative number) is smaller than &gt;7030.</p>
<p><a name="LEQI"></a><b>LEQI<br>
</b>Less Than or Equal Integer. Places "true" on the stack if
the second integer from the top of the stack is smaller than or equal
to
the integer on top of the stack. This is a signed comparison, i.e.
&gt;FFFF
(minus one) is smaller than &gt;0001.</p>
<p><a name="GEUSW"></a><b>GEUSW<br>
</b>Greater or Equal UnSigned Word. Places "true" on the stack
if the second integer from the top of the stack is greater than or
equal
to the integer on top of the stack. This is an unsigned comparison,
i.e.
&gt;8002 is greater than &gt;7030.</p>
<p><a name="LEUSW"></a><b>LEUSW<br>
</b>Lower or Equal UnSigned Word. Places "true" on the stack
if the second integer from the top of the stack is smaller than or
equal
to the integer on top of the stack. This is an unsigned comparison,
i.e.
&gt;FFFF is greater than &gt;0001.</p>
<p><a name="EQREAL"></a><b>EQREAL<br>
</b>EQual REALs. Places "true" on the stack if the two reals
on top of the stack are identical.</p>
<p><a name="GEREAL"></a><b>GEREAL<br>
</b>Greater or Equal REAL. Places "true" on the stack if the
second real number from the top of the stack is greater than or equal
to
the real number on top of the stack. This is an signed comparison, by
definition.</p>
<p><a name="LEREAL"></a><b>LEREAL<br>
</b>Less than or Equal REAL. Places "true" on the stack if the
second real number from the top of the stack is lower than or equal to
the real number on top of the stack. This is an signed comparison, by
definition.</p>
<p><br>
The following operations deal with array of bytes. The stack can
contain
either the address of an array or its offset whithin the segment. Extra
parameters in the code stream decide which it is.</p>
<p><a name="EQBYT"></a><b>EQBYT &lt;UB1&gt;,&lt;UB2&gt;,&lt;B&gt;<br>
</b>The two words on top of the stack should contain either the
addresses
of two byte arrays, or their offset in the current segment. UB1 and UB2
determine whether the address (UBx = 0) or the offset (UBx &lt;&gt; 0)
is used: UB1 refers to the word on top of the stack, UB2 to the word
below.
B is the size of the array. The arrays are compared byte per byte in
the
natural order. If they are identical "true" is placed on the
stack.</p>
<p><a name="GEBYT"></a><b>GEBYT &lt;UB1&gt;,&lt;UB2&gt;,&lt;B&gt;<br>
</b>Greater or Equal BYTe array. Same as above, but the comparison
stops
as soon as a mismatch is encountered. It returns "true" if the
mismatched byte in the "bottom" array (pointed by the second
word from the top of the stack) is greater than a byte in the "top"
array, or if both arrays are identical.</p>
<p><a name="LEBYT"></a><b>LEBYT &lt;UB1&gt;,&lt;UB2&gt;,&lt;B&gt;<br>
</b>Less or Equal BYTe array. Same as above, but the comparison returns
"true" if the first mismatched byte in the bottom array is lower
than the corresponding byte in the top array (or if there is no
mismatch).</p>
<p><br>
The following p-codes deal with strings. A string is essentially the
same
than an array of bytes, excepts that it begins with a length byte. Thus
string comparisons begin with the second byte. If both strings are
identical
(upto the end of the shorter one), the size bytes are compared.</p>
<p><a name="EQSTR"></a><b>EQSTR &lt;UB1&gt;,&lt;UB2&gt;<br>
</b>EQual STRing. The two words on top of the stack should contain
either
the addresses of two strings, or their offset in the current segment.
UB1
and UB2 determine wether the address (UBx = 0) or the offset (UBx
&lt;&gt;
0) is used: UB1 refers to the word on top of the stack, UB2 to the word
below. The strings are compared byte per byte from the second byte to
the
end of the shorter string. If they are identical, their first bytes
(the
size) are compared. If these are identical, "true" is placed
on the stack.</p>
<p><a name="GESTR"></a><b>GESTR &lt;UB1&gt;,&lt;UB2&gt;<br>
</b>Greater or Equal STRing. Same as above, but the comparison stops as
soon as a mismatch is encountered. It returns "true" if the mismatched
byte in the "bottom" string (pointed by the second word from
the top of the stack) is greater than a byte in the "top" string
or if both arrays are identical.</p>
<p><a name="LESTR"></a><b>LESTR &lt;UB1&gt;,&lt;UB2&gt;<br>
</b>Less or Equal String. Same as above, but the comparison returns
"true"
if the first mismatched byte in the string is lower than the
corresponding
byte in the top string (or if there is no mismatch).</p>
<p><br>
The following p-codes deal with packed sets, and don't ask me why they
are abbreviated PWR (packed words? power?). A set consists in upto 255
words to be accessed on a bitwise basis, preceded with a length word
(that
contains the number of words in the set).</p>
<p><a name="EQPWR"></a><b>EQPWR<br>
</b>The two sets on top of the stack are compared upto the end of the
shorter
one. "True" is pushed on the stack of no mismatch is found (even
if the sets are not the same size).</p>
<p><a name="GEPWR"></a><b>GEPWR<br>
</b>"True" is pushed on the stack if the set on top of the stack
is a subset of the set below is. Which means that all the "1"
bits in the top set are also "1" is the bottom set (I think).</p>
<p><a name="LEPWR"></a><b>LEPWR<br>
</b>"True" is pushed on the stack if the set on top of the stack
is a superset of the set below it, "false" is pused otherwise.</p>
<h4><br>
<a name="flow control"></a>Flow control</h4>
<p>Now that we have placed a boolean on top of the stack with a
comparison,
we can use the following p-code to perform conditional jumps. The
address
where to jump to is expressed as an offset in bytes, relative to the
next
instructio. This nifty feature allows a p-code program to be shifted in
memory during execution without messing up all the addresses.</p>
<p><a name="TJP"></a><b>TJP &lt;SB&gt;<br>
</b>True JumP. Jumps by SB bytes if the boolean word on top of the
stack
is "true" (i.e. its last bit is 1).</p>
<p><a name="FJP"></a><b>FJP &lt;SB&gt;<br>
</b>False JumP. Jumps by SB bytes (relative to the next instruction) if
the boolean word on top of the stack is "false" (i.e. its rightmost
bit is 0).</p>
<p><a name="FJPL"></a><b>FJPL &lt;W&gt;<br>
</b>False JumP Long. Same as above, but the offset is expressed as a
word,
which means that you can jump futher than away than -128 to +127 bytes.
(And why on hearth is there no "true jump long" ?).</p>
<p><a name="UJP"></a><b>UJP &lt;SB&gt;<br>
</b>Unconditional JumP. Jumps by SB bytes (-128 to +127 relative to the
next instruction). The stack is ignored and not affected.</p>
<p><a name="UJPL"></a><b>UJPL &lt;W&gt;<br>
</b>Unconditional JumP Long. Same as above, but in the ranger -32768 to
32767 bytes relative to the next instruction.</p>
<p><br>
Alternatively, we can compare integers and perform the jump with a
single
instruction:</p>
<p><a name="EFJ"></a><b>EFJ &lt;SB&gt;<br>
</b>Equal False Jump. Jumps by SB bytes (relative to the next
instruction)
if the two integers on top of the stack are different.</p>
<p><a name="NFJ"></a><b>NFJ &lt;SB&gt;<br>
</b>Not equal False Jump. These guys like double negations! Jumps by SB
bytes if it is false that the two words on top of the stack are not
equal.
In layman's terms this means that the jump if taken if the words are
identical.</p>
<p><br>
Here is a more sophisticated form of jump:</p>
<p><a name="XJP"></a><b>XJP &lt;B&gt;<br>
</b>case JumP (what does the X stand for in "case"?). B is the
offset of a jump table in the constant pool. The integer on top of the
stack should be an index whithin that table. The corresponding word in
the table is used as a jump offset, relative to the next instruction. A
jump table begins with two words that indicate the minimum and the
maximum
index, if the integer on top of the stack is not in this range, no jump
is taken.</p>
<p>Example of a jump table created by the Pascal instruction:</p>
<pre>case I of                       &gt;0002  Minimum index (table begins at 2)<br> 2: xxx ;                       &gt;0005  Maximum index (table ends at 5)<br> 5: xxx ;                       &gt;FFFA  Jump offset for I=2<br> 3:xxx;                         &gt;FFFE  Jump offset for I=3<br>end;                            &gt;0000  No jump for 4 (as it does not exist)<br>                                &gt;FFFC  Jump offset for I=5</pre>
<p><br>
Two more p-codes that can fall in the category of flow controlling
instructions:</p>
<p><a name="BPT"></a><b>BPT<br>
</b>BreakPoinT. A breakpoint execution error (number 16) is issued
unconditionally.
This will result in entering the debugger, if it is running. NB The
debugger
is not implemented on the TI-99/4A (rats!).</p>
<p><a name="CHK"></a><b>CHK<br>
</b>CHecK subrange bounds. The stack contains three integers, from top
to bottom: the upper limit, the lower limit and the test value. If the
test value does not fall whithing the specified range (as judged by
signed
comparisons) a value range execution error is issued. After the
instruction,
the two limits are removed but the test value remains on the stack.</p>
<pre>Examples:<br>44           32              44<br>12          -21              12<br>18            0            1233<br>OK           OK            Error</pre>
<h4><br>
<br>
<a name="strings"></a>Arrays and strings</h4>
<p>Arrays can contain elements of any size, but all elements in the
array
must have the same size. If the size is not a multiple of a byte (e.g.
if it is 10 bits, or 3 bits) elements can be squeezed together,
regardless
of byte boundaries. This is called a packed array, just like in Pascal.</p>
<p>A string is an array of characters terminated with a nul byte
(&gt;00).
</p>
<p><a name="ASTR"></a><b>ASTR &lt;UB1&gt;,&lt;UB2&gt;</b></p>
<p>Assign STRing. Copies the string whose address is at the top of the
stack, into another string whose address is just below on the stack.
UB2
is the size of the string. UB1 determines whether the source string is
a variable (UB1=0) or a constant (in which case the word at top of
stack
is an offset in the constant pool). If the source string happens to be
greater than UB2 bytes, a "string overflow" execution error occurs.</p>
<p><a name="CAP"></a><b>CAP &lt;B&gt;</b></p>
<p>Copy Array Parameters. Pretty much like CSP, but the parameter
copied
is a packed array of characters (i.e. is not necessarily
nul-terminated).
Thus, there can be no check for size, and &lt;B&gt; characters are
always
copied to the buffer. </p>
<p><a name="CSP"></a><b>CSP &lt;UB&gt;</b></p>
<p>Copy String Parameter. This instruction is usefull to copy a
function
parameter into a local variable: </p>
<pre>MyFunction( S1: string);<br>{<br>    var S2: string;<br>}</pre>
<p>For obvious reasons, string parameters are passed by pointers. The
word
on top of the stacks is the address of a two-word parameter descriptor.
If the bottom word of the descriptor is NIL, the second word is the
address
of the string parameter (S1 in the above example). Alternatively, the
bottom
word can be a pointer to an E_Rec (environment record), in which case
the
second word is the offset of the string in the segment corresponding to
this E_Rec. If this segment is not resident, a segment fault occurs.</p>
<p>The second word from the top of the stack is the address of a local
string buffer (S2 in the exemple) into which the string parameter will
be copied. UB indicates the size of this buffer. If the parameter
string
happens to be larger, a "string overflow" execution error occurs.
</p>
<p><a name="CSTR"></a><b>CSTR</b></p>
<p>Check STRing index. The integer on top of the stack is an index
inside
a string whose address is in the word below it. If this index is less
than
1, or greater than the dynamic length of the string, a "value range"
execution error occurs.</p>
<p><a name="IXA"></a><b>IXA &lt;B&gt;</b></p>
<p>IndeX Array. The integer on top of the stack in an index inside an
array
whose address is in the word below it. B is the size in words of an
array
element. These two words are removed from the stack and replaced with
the
address of the corresponding element. The algorithm is: Result =
Address
+ (Index * &lt;B&gt; * atype), where atype is 1 for word-addressed
computers
and 2 for byte-addressed computers.</p>
<p><a name="IXP"></a><b>IXP &lt;UB1&gt;,&lt;UB2&gt;</b></p>
<p>IndeX Packed array. The integer on top of the stack in an index
inside
a packed array (i.e. an array of bit-fields) whose address is in the
word
below it. UB1 is the number of elements per word, UB2 is the size in
bits
of an element . These two words are removed from the stack and replaced
with the corresponding element. <br>
</p>
<h4><br>
<a name="sets"></a>Sets</h4>
<p>A set consits in 0 to 255 words of bit flags, preceded by a word
that
indicates the total number of words in the set. Bits are numbered from
0, starting with the rightmost bit of the first word. A bit set to "1"
indicates that the corresponding number is present in the set, a "0"
that it is not a member of the set.</p>
<p>Example: </p>
<p>The set [0,3,5,7] is represented as:</p>
<pre><u>00000000 00000001</u>  00000000 10101001<br>Size in words (=1) Bits:    7 5 3  0<br></pre>
<p><br>
<a name="ADJ"></a><b>ADJ &lt;UB&gt;</b></p>
<p>The set on top of the stack is stripped of its length word, then
expanded
or compressed until is UB words in length. Compression removes the high
words of the set (even if they do not contain zero!), expansion adds
zero-words
on top of the stack.</p>
<p>If, after the operation, less than 20 words remain free for the
stack
to grow, a stack fault is issued.</p>
<p><a name="SRS"></a><b>SRS</b></p>
<p>SubRangeSet. Two integers in the range 0 to 4097 should be on top of
the stack (if not, a "value range" execution error occurs). If
the top word is the smallest, the empty set is placed on the stack.
Otherwise,
a set is placed on the stack in which all bits between these two
integers
(included) are set as "1".</p>
<p>If less than 20 words remain available on the stack after execution,
a stack fault is issued.</p>
<p><a name="INN"></a><b>INN</b></p>
<p>INcluded iN. Checks for set membership. The word on top of the stack
is the index of a bit in the set below it. If this bit is "1",
the stack will contain "true" after the operation, otherwise
it will contain "false". Note that bit numbering starts from
zero, with the rightmost bit of a word.</p>
<p><a name="DIF"></a><b>DIF</b></p>
<p>DIFference. Removes the two sets on top of the stack and replaces
them
a set corresponding to their bitwise difference. The difference is
computed
as: Set1 AND NOT Set2 ( 0 DIF&nbsp; 0 = 0, 0 DIF&nbsp;1 = 0, 1 DIF 0 =
1, 1 DIF 1= 0).</p>
<p><a name="INT"></a><b>INT</b></p>
<p>INTersection. The intersection of the two sets on top of the stack
is
computed as Set1 AND Set2 and the resulting set replaces these two on
the
stack.</p>
<p><a name="UNI"></a><b>UNI</b></p>
<p>UNIon. The two sets on top of the stack are replaced with their
bitwise
union. The union is computed as: Set1 OR Set2.</p>
<h4><br>
<a name="multitasking"></a>Multitasking</h4>
<p><a name="WAIT"></a><b>WAIT</b></p>
<p>Waits for a semaphore. The word on top of the stack is the address
of
this semaphore. If the semaphore value is greater than zero it is
decremented
and execution continues. If it is zero, the current tasks must wait for
the semaphore to become available. To this end, the current TIB is
placed
in the semaphore's queue (and Hang_Ptr in the TIB will point to the
semaphore).
Then the p-system switches to another task.</p>
<p><a name="SIGNAL"></a><b>SIGNAL</b></p>
<p>Signals a semaphore. The word on top of the stack is the address of
this semaphore. If the semaphore is less than zero (or if its queue is
empty) it is incremented and execution continues. Otherwise, the first
task waiting for this semaphore is removed from the semaphore queue and
placed in the queue of tasks ready to run (and the Hang_Ptr in its TIB
is set to NIL). If this task has a higher priority than the current
one,
the p-system switches to it.</p>
<h4><br>
<a name="misc instructions"></a>Others p-codes</h4>
<p>These do not fit in any of the above categories.</p>
<p><a name="LPR"></a><b>LPR</b></p>
<p>Load Processor Register. The word on top of the stack is a register
number. It will be replaced on the stack by the content of this
register.
The register numbers are:</p>
<p>-3: READYQ<br>
-2: EVEC<br>
-1: CURTASK<br>
0: Wait-Q<br>
1: Prior | Flags<br>
2: SP_Low<br>
3: SP_Up<br>
4: SP<br>
5: MP<br>
6: (reserved)<br>
7: IPC<br>
8: Env<br>
9: Proc_Num | TIB_IOresult<br>
10: Hang_Ptr<br>
11: M_Depend</p>
<p><a name="SPR"></a><b>SPR</b></p>
<p>Store Processor Registers. The word on top of the stack is stored in
the register whose number is in the word below it. See LPR for the
register
numbers. If the number is 0 or greater, all registers are first saved
in
the TIB, then the adequate value is placed in the TIB, finally all
registers
are restored from the TIB.</p>
<p><a name="NAT"></a><b>NAT</b></p>
<p>Enter NATive code. Starts executing assembly language right after
this
p-code. It may be necessary to increment IPC to a word boundary on
word-oriented
processors (such as the TMS9900).</p>
<p><a name="NAT-INFO"></a><b>NAT-INFO &lt;B&gt;</b></p>
<p>Same as NAT, but IPC will be incremented by B before entering
assembly
language (i.e. it acts as a jump). If B=0, the first execution begins
with
the byte right after B in the code stream. This allows place infomation
for the native-code generators uptream of a stretch of assembly
language.</p>
<p><a name="NOP"></a><b>NOP</b></p>
<p>No OPeration. Execution continues.</p>
<p><a name="RESERVE"></a><b>RESERVEn</b></p>
<p>Where n is a number from 1 to 6. These p-codes are reserved for
internal
used by compilers. Trying to execute them generates an "unimplemented"
execution error.</p>
<h3><br>
<br>
<a name="Standard procedures"></a>Standard procedures</h3>
<p>A number of standard procedures have been included whithin the PME,
either for speed, or because they contain some assembly language. These
procedures should be called with CXG or SCXG1. Most of them expect
parameters
on the stack, and some return a result on the stack. In any case, the
initial
parameters will be removed from the stack by the procedure itself. The
standard procedures differ from user-written procedures in that they do
not return with RPU. In a sense, they can be viewed as extra p-codes...</p>
<p>For consistency I listed them in their Pascal form, but you can
easily
convert the declarations into a stack description. For instance, with
the
following procedure</p>
<p><tt>DUMMY(UNIT: integer, PTR:addr): Boolean </tt></p>
<p>the stack would look like this</p>
<pre> ______ &lt;         <br>|<u> addr </u>| <br>|<u> int  </u>|         <u>      </u> &lt; <br>|<u>  0   </u>|        |<u> bool </u>|        <br>|//////|        |//////|<br> Before          After   </pre>
<p>To call a procedure from assembly or p-code (when using a p-code
assembler),
you should push zero on the stack if the function is returning a value,
then push the parameters in the order they appear in the Pascal
declaration,
and finally call the procedure. When it returns, make sure you pop the
return value from the stack, if there is one.<br>
<br>
</p>
<table border="1">
  <tbody>
    <tr>
      <th>Number </th>
      <th>Name</th>
      <th>Parameters</th>
      <th>Returns</th>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#RELOCSEG">RELOCSEG</a></td>
      <td>EREC: E_Rec</td>
      <td>-</td>
    </tr>
    <tr>
      <td>14</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#MOVESEG">MOVESEG</a></td>
      <td>SIB: addr<br>
POOL: addr<br>
OFFSET: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>15</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#MOVELEFT">MOVELEFT</a></td>
      <td>SOURCE: byte_ptr <br>
DEST: byte_ptr<br>
LEN: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>16</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#MOVERIGHT">MOVERIGHT</a></td>
      <td>SOURCE: byte_ptr<br>
DEST: byte_ptr<br>
LEN: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>18</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITREAD">UNITREAD</a></td>
      <td>UNIT: integer<br>
BUFFER: byte_ptr<br>
LEN: integer<br>
BLOCK: integer <br>
CTRL: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>19</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITWRITE">UNITWRITE</a></td>
      <td>UNIT: integer<br>
BUFFER: byte_ptr<br>
LEN: integer<br>
BLOCK: integer <br>
CTRL: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>20</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#TIME">TIME</a></td>
      <td>HIWORD: addr<br>
LOWORD: addr</td>
      <td>-</td>
    </tr>
    <tr>
      <td>21</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#FILLCHAR">FILLCHAR</a></td>
      <td>DESTR: byte_ptr<br>
LEN: byte_ptr<br>
CHAR: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>22</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SCAN">SCAN</a></td>
      <td>LEN: integer<br>
EXP: Boolean<br>
CHAR: byte<br>
SOURCE :byte_ptr<br>
MASK: word</td>
      <td>integer</td>
    </tr>
    <tr>
      <td>23</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#IOCHECK">IOCHECK</a></td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>24</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#GETPOOLBYTES">GETPOOLBYTES</a> </td>
      <td>DEST: addr<br>
POOL: addr<br>
OFFSET: integer<br>
NBYTES: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>25</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#PUTPOOLBYTES">PUTPOOLBYTES</a></td>
      <td>SOURCE: addr<br>
POOL: addr<br>
OFFSET: integer<br>
NBYTES: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>26</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#FLIPSEGBYTES">FLIPSEGBYTES</a></td>
      <td>EREC: addr<br>
OFFSET: integer<br>
NWORDS: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>27</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#QUIET">QUIET</a></td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>28</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ENABLE">ENABLE</a></td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>29</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ATTACH">ATTACH</a></td>
      <td>SEM: addr<br>
VECTOR: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>30</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#IORESULT">IORESULT</a></td>
      <td>-</td>
      <td>integer</td>
    </tr>
    <tr>
      <td>31</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITBUSY">UNITBUSY</a></td>
      <td>UNIT: integer</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>32</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#POWEROFTEN">POWEROFTEN</a></td>
      <td>POWER: integer</td>
      <td>real</td>
    </tr>
    <tr>
      <td>33</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITWAIT">UNIWAIT</a></td>
      <td>UNIT: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>34</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITCLEAR">UNITCLEAR</a></td>
      <td>UNIT: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>36</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#UNITSTATUS">UNITSTATUS</a></td>
      <td>UNIT: integer<br>
STAT_REC: addr<br>
CTRL: integer</td>
      <td>-</td>
    </tr>
    <tr>
      <td>37</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#IDSEARCH">IDSEARCH</a></td>
      <td>SYMREC: addr<br>
BUFFER: addr</td>
      <td>integer</td>
    </tr>
    <tr>
      <td>38</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#TREESEARCH">TREESEARCH</a></td>
      <td>ROOT: addr<br>
FOUNDP: addr<br>
TARGET: addr</td>
      <td>integer</td>
    </tr>
    <tr>
      <td>39</td>
      <td><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#READSEG">READSEG</a></td>
      <td>EREC: addr</td>
      <td>integer</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="Unit-related"></a>Unit-related procedures</h4>
<p>All these procedures place status information in IORESULT, upon
return.
See <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ioresult">below</a> for details.</p>
<p><a name="UNITCLEAR"></a><b>UNITCLEAR(UNIT: integer)</b></p>
<p>UNIT is the unit number. The procedure initializes the unit and
returns
its status into the p-machine register IORESULT.</p>
<p><br>
<a name="UNITSTATUS"></a><b>UNITSTATUS(UNIT: integer; STAT_REC:addr;
CTRL:integer)</b></p>
<p>UNIT is the unit number.<br>
STAT_REC is the address of a status record.<br>
If CTRL is 0 status is written, if CTRL is 1 status is read.</p>
<p><br>
<a name="UNITREAD"></a><b>UNITREAD(UNIT:integer; BUFFER:byte_ptr;
LEN:integer;
BLOCK:integer; CTRL:integer)</b></p>
<p>This procedures reads a number of bytes from a unit into a buffer.</p>
<p>UNIT is the unit number<br>
BUFFER is a pointer to the destination buffer<br>
LEN is the numbe of bytes to read<br>
BLOCK is the number of the desired data block within the unit<br>
CTRL selects the input mode (see BIOS for details)</p>
<p><br>
<a name="UNITWRITE"></a><b>UNITWRITE(UNIT:integer; BUFFER:byte_ptr;
LEN:integer;
BLOCK:integer; CTRL:integer)</b></p>
<p>This procedures writes a number of bytes from a buffer into a unit.</p>
<p>UNIT is the unit number<br>
BUFFER is a pointer to the source buffer<br>
LEN is the numbe of bytes to write<br>
BLOCK is the number of the target data block within the unit<br>
CTRL selects the input mode (see BIOS for details)</p>
<p><br>
<a name="UNITWAIT"></a><b>UNITWAIT(UNIT: integer)</b></p>
<p>This procedure waits until all I/O on this unit is completed.</p>
<p><br>
<a name="UNITBUSY"></a><b>UNITBUSY(UNIT:integer) :boolean</b></p>
<p>This procedure returns TRUE if there are any pending I/O operations
in the unit, and FALSE otherwise.</p>
<p><br>
<a name="IORESULT"></a><b>IORESULT(): integer</b></p>
<p>This procedure returns the value of the IORESULT register.</p>
<p><br>
<a name="IOCHECK"></a><b>IOCHECK()</b></p>
<p>This procedure verifies that the IORESULT register contains zero. If
not, an I/O execution error is issued.</p>
<h4><br>
<a name="string-related"></a>String-related procedures</h4>
<p><a name="MOVELEFT"></a><b>MOVELEFT(SOURCE:byte_ptr; DEST:byte_ptr;
LEN:integer)</b></p>
<p>This procedure moves a number of bytes from the source string to the
destination string, starting from the left (low-order) byte. If LEN is
0 or less, nothing happens.</p>
<p><br>
<a name="MOVERIGHT"></a><b>MOVERIGHT(SOURCE:byte_ptr; DEST:byte_ptr;
LEN:integer)</b></p>
<p>This procedures moves a number of bytes from the source string to
the
destination string, starting from the right (high order) byte. If LEN
is
0 or less, nothing happens.</p>
<p><br>
<a name="FILLCHAR"></a><b>FILLCHAR(DEST:byte_ptr; LEN:byte_ptr;
CHAR:integer)</b></p>
<p>The destination string will be filled with the LEN copies of
character
CHAR. If LEN is 0 or less, nothing happens.</p>
<p><br>
<a name="SCAN"></a><b>SCAN(LEN:integer; EXP:Boolean; CHAR:byte;
SOURCE:byte_ptr;
MASK:word): integer</b></p>
<p>This procedure looks for a character in a string.</p>
<p>If EXP is 0, the procedure scans the string SOURCE for LEN bytes,
until
it finds the byte CHAR.<br>
If EXP is 1, the procedure scans SOURCE for a byte different from CHAR.<br>
LEN is the maximum number of bytes to scan. If it is negative, scanning
proceeds from right to left.<br>
MASK is not used.</p>
<p>The function returns the offset of CHAR within SOURCE (or LEN if no
match was found).</p>
<h4><br>
<a name="code pool-related"></a>Code pool management procedures</h4>
<p><a name="RELOCSEG"></a><b>RELOCSEG(EREC:E_Rec)</b></p>
<p>Relocates the segment pointed at by the environment record EREC. All
types of relocations are performed.</p>
<p><br>
<a name="MOVESEG"></a><b>MOVESEG(SIB:addr; POOL:addr; OFFSET:integer)</b></p>
<p>SIB is a pointer to a segment information block that should contain
the address where the segment should be moved. <br>
OFFSET is the offset whithin the code pool of the segment to be moved.
<br>
POOL points to a code pool descriptor, the first two words of which are
a pointer to the base of the code pool.</p>
<p>The segment found at the specified offset whithin the code pool will
be moved at the location specified in the SIB and relocated. Only
segment-relative
relocation is performed (as other types are not affected by the move).</p>
<p><a name="GETPOOLBYTES"></a><b>GETPOOLBYTES(DEST:addr; POOL:addr;
OFFSET:integer;
NBYTES:integer)</b></p>
<p>This procedure copies a number of bytes from the code pool into a
buffer.</p>
<p>DEST is the address of the destination buffer.<br>
POOL is the address of a code pool descriptor, the first two words of
which
point to base of the pool.<br>
OFFSET is the offset of the first byte to transfer, relative to the
base
of the pool.<br>
NBYTES is the number of bytes to transfer.</p>
<p><a name="PUTPOOLBYTES"></a><b>PUTPOOLBYTES(DEST:addr; POOL:addr;
OFFSET:integer;
NBYTES:integer)</b></p>
<p>This procedures copies NBYTES bytes from buffer SOURCE into a code
pool
described in POOL, starting at offset OFFSET. It's the opposite of the
above.</p>
<p><a name="FLIPSEGBYTES"></a><b>FLIPSEGBYTES(addr:EREC, int:OFFSET,
int:NWORDS:int)</b></p>
<p>This procedures flips the bytes within a number of words of a
segment.</p>
<p>EREC is the address of an environment record describing the segment.<br>
OFFSET is the word offset where byte flipping should start.<br>
NWORDS is the number of words whose bytes should be flipped.</p>
<p><a name="READSEG"></a><b>READSEG(EREC:addr): integer</b></p>
<p>This procedures reads a segment into memory.</p>
<p>EREC is the address of an environment record describing the segment.
Inside the E_Rec is a pointer to the SIB (segment information block)
that
contains the address where the segment should be read.</p>
<p>The procedure returns the contents of the IORESULT register.</p>
<h4><br>
<a name="concurency-related"></a>Concurency procedures</h4>
<p><a name="ATTACH"></a><b>ATTACH(SEM:addr, VECTOR:integer)</b></p>
<p>This procedure associates a semaphore with a p-machine event. The
semaphore
will be signaled each time the desired event occurs. </p>
<p>SEM is the address of a semaphore. If it is NIL, the event be
detached
from any existing semaphore.<br>
VECTOR is the number of a p-machine event vector. It should be in the
range
0 to 63, otherwise nothing happens. I have no idea what the events
are...</p>
<p><a name="QUIET"></a><b>QUIET()</b></p>
<p>This procedure disables all p-machine events such that no attached
semaphore
is signalled until ENABLE is called.</p>
<p><a name="ENABLE"></a><b>ENABLE()</b></p>
<p>This procedure re-enables the p-machine events that were disabled by
QUIET.</p>
<h4><br>
<a name="misc procedures"></a>Miscellaneous procedures</h4>
<p><a name="TIME"></a><b>TIME(HIWORD:addr; LOWORD:addr)</b></p>
<p>Saves the value of the p-system clock into the indicated words. This
clock is a 32-bit number, incremented 60 times per seconds.</p>
<p><a name="POWEROFTEN"></a><b>POWEROFTEN(POWER:integer): real</b></p>
<p>Returns a real number equals to 10 to the power of POWER. If POWER
is
negative or too big, a floating point execution error is issued.</p>
<h4><br>
<a name="compiler-related"></a>Compiler usage procedures</h4>
<p>These two procedures are used by the Pascal compiler. They have
nothing
to do in the PME, and were only placed here to speed up compilation.</p>
<p><a name="TREESEARCH"></a><b>TREESEARCH(ROOT:addr; FOUNDP:addr;
TARGET:addr):
integer</b></p>
<p>This procedure searches the symbol table tree for a target string.
Each
tree node is expected to have the following structure:</p>
<pre> RECORD<br>  Name:&nbsp;PACKED&nbsp;ARRAY[0..7] of CHAR;<br>  Right_link: pointer;<br>  Left_link: pointer;<br> END</pre>
<p>ROOT is the address of the (sub)tree in the symbol table.<br>
TARGET is the address of the string to look for, a packed array of 8
characters.<br>
FOUNDP is the address where to put the result of the search, i.e. where
the string was found.</p>
<p>If the target string was found, the function returns 0 and places a
pointer to the leaf node that contains it into FOUNDP.<br>
If the target was not found, FOUNP will point to the last node that was
scanned and the function return 1 of the target should be placed to the
right of this node, -1 if it should go to the left.</p>
<p><a name="IDSEARCH"></a><b>IDSEARCH(SYMREC:addr; BUFFER:addr)</b></p>
<p>This procedure scans a line of text for a Pascal keyword.</p>
<p>BUFFER is the address of the buffer to scan<br>
SYMREC is the address of a record with the following structure:</p>
<pre> RECORD<br>  SYMCURSOR: integer;<br>  SY: integer;<br>  OP: integer;<br>  ID: PACKED&nbsp;ARRAY[0..7] OF CHARS;<br> END</pre>
<p>The procedure scans BUFFER, starting at position SYMCURSOR, looking
for an identifier. An identifier is a string containing only letters,
digits
and underscore, that begins with a letter. Upon return the first 8
characters
of the identifier will be placed in ID, using padding spaces if needed,
and SYMCURSOR will be updated to point after the identifier. Finally,
the
function looks up a table of reserved words and placed the
corresponding
values in SY and OP.</p>
<p>Here are the reserved words recognised by the procedure, and the
return
values. The table is laid out in two columns for convenience.</p>
<table border="1">
  <tbody>
    <tr>
      <th>ID</th>
      <th>SY </th>
      <th>OP </th>
      <th>ID</th>
      <th>SY </th>
      <th>OP </th>
    </tr>
    <tr>
      <td>AND</td>
      <td>39</td>
      <td>2</td>
      <td>NOT</td>
      <td>38</td>
      <td>15</td>
    </tr>
    <tr>
      <td>ARRAY</td>
      <td>44</td>
      <td>15</td>
      <td>OF</td>
      <td>11</td>
      <td>15</td>
    </tr>
    <tr>
      <td>BEGIN</td>
      <td>19</td>
      <td>15</td>
      <td>OR</td>
      <td>40</td>
      <td>7</td>
    </tr>
    <tr>
      <td>CASE</td>
      <td>21</td>
      <td>15</td>
      <td>PACKED </td>
      <td>43</td>
      <td>15</td>
    </tr>
    <tr>
      <td>CONST</td>
      <td>28</td>
      <td>15</td>
      <td>PROCEDUR </td>
      <td>31</td>
      <td>15</td>
    </tr>
    <tr>
      <td>DIV</td>
      <td>39</td>
      <td>3</td>
      <td>PROCESS</td>
      <td>56</td>
      <td>15</td>
    </tr>
    <tr>
      <td>DO</td>
      <td>6</td>
      <td>15</td>
      <td>PROGRAM</td>
      <td>33</td>
      <td>15</td>
    </tr>
    <tr>
      <td>DOWNTO</td>
      <td>8</td>
      <td>15</td>
      <td>REPEAT</td>
      <td>22</td>
      <td>15</td>
    </tr>
    <tr>
      <td>ELSE</td>
      <td>3</td>
      <td>15</td>
      <td>RECORD</td>
      <td>45</td>
      <td>15</td>
    </tr>
    <tr>
      <td>END</td>
      <td>9</td>
      <td>15</td>
      <td>SET</td>
      <td>42</td>
      <td>15</td>
    </tr>
    <tr>
      <td>EXTERNAL</td>
      <td>53</td>
      <td>15</td>
      <td>SEGMENT</td>
      <td>33</td>
      <td>15</td>
    </tr>
    <tr>
      <td>FILE</td>
      <td>46</td>
      <td>15</td>
      <td>SEPARATE</td>
      <td>54</td>
      <td>15</td>
    </tr>
    <tr>
      <td>FOR</td>
      <td>2</td>
      <td>15</td>
      <td>THEN</td>
      <td>12</td>
      <td>15</td>
    </tr>
    <tr>
      <td>FORWARD</td>
      <td>34</td>
      <td>15</td>
      <td>TO</td>
      <td>7</td>
      <td>15</td>
    </tr>
    <tr>
      <td>FUNCTION</td>
      <td>32</td>
      <td>15</td>
      <td>TYPE</td>
      <td>29</td>
      <td>15</td>
    </tr>
    <tr>
      <td>GOTO</td>
      <td>26</td>
      <td>15</td>
      <td>UNIT</td>
      <td>50</td>
      <td>15</td>
    </tr>
    <tr>
      <td>IF</td>
      <td>20</td>
      <td>15</td>
      <td>UNTIL</td>
      <td>10</td>
      <td>15</td>
    </tr>
    <tr>
      <td>IMPLEMENT</td>
      <td>52</td>
      <td>15</td>
      <td>USES</td>
      <td>49</td>
      <td>15</td>
    </tr>
    <tr>
      <td>IN</td>
      <td>41</td>
      <td>14</td>
      <td>VAR</td>
      <td>30</td>
      <td>15</td>
    </tr>
    <tr>
      <td>INTERFAC</td>
      <td>51</td>
      <td>15</td>
      <td>WHILE</td>
      <td>23</td>
      <td>15</td>
    </tr>
    <tr>
      <td>LABEL</td>
      <td>27</td>
      <td>15</td>
      <td>WITH</td>
      <td>25</td>
      <td>15</td>
    </tr>
    <tr>
      <td>MOD</td>
      <td>39</td>
      <td>4</td>
      <td>unknown </td>
      <td>0</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
<h3><br>
<br>
<a name="Faults&amp;errors"></a>Faults and execution errors</h3>
<p>Two types of problems can occur while executing p-codes: faults and
execution errors. A fault is a benigne condition, that requires the
assistance
of the p-system to be fixed. After this is done, execution can
continue.
By contrast, an execution error is generally fatal and will result in
terminating
the program that caused it and reseting the p-system.</p>
<h4>Faults</h4>
<p>The PME only generates two types of faults: segment faults and stack
faults. </p>
<p><b>Segment faults</b> occurs when a p-code tries to access a segment
that is not (yet) in memory. These p-codes are: CAP, CSP, CXL, SCXGn,
CXG,
CXI, CFP, RPU, SIGNAL and WAIT. The p-machine signals the semaphore
Real_Sem
to allert the p-system and the fault condition is handled by the high
priority
task Fault_Handler, which is part of the KERNEL unit. Typically, this
will
result in loading the required segment into memory. </p>
<p><b>Stack faults</b> occurs when there is not enough room on the
stack.
Only p-codes that place multiple words on the stack check it for room
(except
for real numbers). These p-codes are: ADJ, CFP, CGP, SCIPn, CIP, CLP,
CXL,
SCXGn, CXG, LDC, and LDM. Here, Fault_Handler will try to compact the
memory
so as to free some more room for the stack. </p>
<p>Before signalling Real_Sem, the PME saves some values into the
SYSCOM
area for Fault_Handler to use. These are:</p>
<pre><u>Offset Name         Usage                                         <br></u>14     Real_Sem     Semaphore that Fault_Handler is waiting for<br>18     Fault_TIB    Task info block of the faulting task<br>20     Fault_EREC   E_Rec of the segment to be loaded (current E_rec for stack faults)<br>22     Fault_Words  Number of words needed on stack (0 with segment faults)<br>24     Fault_Type   &gt;80 = PME segment fault, &gt;81 = PME&nbsp;stack fault</pre>
<p>Once the problem has been taken care of, control is returned to the
p-machine emulator and the p-code that caused the fault is executed
again.</p>
<h4><br>
<a name="Execution errors"></a>Execution errors</h4>
<p>When an execution error occurs, the PME calls the procedure
Exec_Error,
which is also part of the Kernel. This call is performed with CXG 1,2
after
placing two zeros on the stack, followed by the error number.</p>
<p>Normally, Exec_Error will not return but rather reset the p-system,
although it is possible to cause it to return (for instance from a
debugger
program).</p>
<p>The possible execution errors are:</p>
<table border="1">
  <tbody>
    <tr>
      <th>Number </th>
      <th>Name</th>
      <th>Culprit </th>
      <th>Description </th>
    </tr>
    <tr>
      <td>1</td>
      <td>Value range error </td>
      <td>CHK, CSTR </td>
      <td>Index out of array bounds</td>
    </tr>
    <tr>
      <td>2</td>
      <td>No proc in seg table </td>
      <td>CLP, CFP, CGP, SCIPn, CIP<br>
CXL,&nbsp;SCXGn, CXG, CXI</td>
      <td>Call to a proc whose dictionary entry<br>
is 0 (probably because it was't linked).</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Integer overflow</td>
      <td>Long integer routines</td>
      <td>Long integer cannot be converted to int,<br>
or too large to be poped from stack.</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Divide by Zero</td>
      <td>DVI, MODI, DVR, long integer</td>
      <td>Division by 0.</td>
    </tr>
    <tr>
      <td>8</td>
      <td>Interrupted by user</td>
      <td>You!</td>
      <td>&lt;Break&gt; key pressed.</td>
    </tr>
    <tr>
      <td>10</td>
      <td>I/O error</td>
      <td>IOCHECK</td>
      <td>IORESULT was not 0.</td>
    </tr>
    <tr>
      <td>11</td>
      <td>Unimplemented </td>
      <td>Any unimplemented p-code</td>
      <td>Illegal or unknown p-code.</td>
    </tr>
    <tr>
      <td>12</td>
      <td>Floating point error</td>
      <td>LDCRL, LDRL, STRL, FLT, TNC,<br>
RND, ASBR, NGR, ADR, SBR, <br>
MPR, DVR, EQREAL, LEREAL, <br>
GEREAL, POWEROFTEN</td>
      <td>Floating point overflow (i.e. result <br>
cannot be expressed as a float).</td>
    </tr>
    <tr>
      <td>13</td>
      <td>String overflow</td>
      <td>CSP, ASTR, long integer routines</td>
      <td>Destination too small to hold the string.</td>
    </tr>
    <tr>
      <td>16</td>
      <td>Break point</td>
      <td>BPT</td>
      <td>This will enter the Debugger, if any.</td>
    </tr>
    <tr>
      <td>18</td>
      <td>Set too large</td>
      <td>SRS</td>
      <td>Set larger than maximum legal size.</td>
    </tr>
    <tr>
      <td>19</td>
      <td>Segment too large</td>
      <td>READSEG</td>
      <td>Segment too large to be read<br>
(this should never happen).</td>
    </tr>
  </tbody>
</table>
<h3><br>
<br>
<a name="data representation"></a>Data representations</h3>
<p>The p-system was designed to run on any computer system, provided
the
proper PME is written. However, different computers handle numbers in a
different way. Everybody agrees on the definition of a byte, but things
become more complicated when it comes to larger numbers.</p>
<h4>Words</h4>
<p>Almost everybody agrees that a word is a 16-bit value, i.e. is made
of two bytes. However, there are two conventions on how to order the
bytes
within a word. For instance, suppose you want to place the number
&gt;1234
in memory, at address &gt;A000-A001. There are two ways to do it:</p>
<pre>+-----+             +-----+<br>| &gt;34 |             | &gt;12 |<br>+-----+ &gt;A001       +-----+  &gt;A001<br>| &gt;12 |             | &gt;34 |<br>+-----+ &gt;A000       +-----+  &gt;A000<br>Big-endian          Little-endian<br>TI, Motorola        Intel, PCs</pre>
<p>With the first convention, the bytes are stored in "natural"
order, i.e. the most significant byte comes first, when moving ahead in
memory. With the second, the most significant byte goes into the
highest
address. TI uses the first convention, so does Motorola (and
consequently
Apple computers), whereas Intel uses the second and so do all PC clones.</p>
<p>As p-code is to be ported on any machine, a considerable effort was
put into it so that it is independent of this so-called "byte sex".
Since all p-codes are bytes, that part was easy. But trouble began with
constants and addresses, which are word-oriented. The following
solution
was adopted: 1) The p-system always uses the byte sex of the machine it
runs onto. 2) Each segment in a code file contains a flag indicating
the
byte sex used by the compiler that created it. If it does not match the
current byte sex, the PME will flip bytes in the relevant portions of
this
segment.</p>
<h4><br>
<a name="Long integers"></a>Long integers</h4>
<p>Again, the definition of a long integer can vary from compiler to
compiler.
Therefore, in the PME, integers can have any size from 2 to 10 words
(thats
160 bits, about 36 decimal digits!). When it's on the stack, an integer
is always preceded by a length word, i.e. a number from 2 to 10,
indicating
the number of words that follow.</p>
<pre>+-----+<br>|&gt;0003|  Size word<br>+-----+<br>|&gt;1234|<br>+-----+<br>|&gt;6635|  3-word Long<br>+-----+<br>|&gt;8701|<br>+-----+<br>|/////|</pre>
<p>However, when a long integer is assigned to a variable, or stored on
disk (e.g. as a constant embedded in a program), the length word is
stripped
and the long integer is forced into the default "long" size on
the current processor. If this conversion is not possible, an "integer
overflow" execution error is issued. </p>
<p>To avoid that kind of problem as much as possible, the routine CVT
should
be used to incorporate long constants into a program. It will convert
an
integer (or any combination thereof) into a long integer constant of
the
size required by the target processor. Thefore the code file will not
contain
any long integer, which makes it fully portable. Long integers will be
created on the fly, when the program is run on the target machine.</p>
<p>Examples:</p>
<pre><u>To code      Use                               <br></u>     12      CVT(12)<br> 225543      CVT(22554)*CVT(10) + CVT(3)<br>-873342     -(CVT(8733)*CVT(1000) + CVT(442))</pre>
<p>As you can see, all the parameters of CVT are integers (-32768 to
+32767)
and can be coded as words. CVT does the dirty work in converting them
to
a long integer of the appropriate size.</p>
<p>The CVT routine actually calls a package of routines that perform
long
integer math. These are part of a Pascal unit called LONGOPS, that
contains
three procedures:</p>
<p>FREADDEC reads a long integer<br>
FWRITEDEC writes a long integer<br>
DECOPS performs several math operations.</p>
<p>A peculiarity of DECOPS is that it takes a variable number of
parameters,
depending on the operation to be performed. This is not correct Pascal,
but it's sure more convenient this way! This is possible because DECOPS
is actually an assembly routine, embedded into the Pascal unit. When
calling
DECOPS, the required parameters are pushed on the stack, followed by
OP,
the number of the operation to be executed (and by the return address,
obviously).</p>
<p>Valid DECOPS operations are:</p>
<table border="1">
  <tbody>
    <tr>
      <th>OP </th>
      <th>Name</th>
      <th>Parameters</th>
      <th>Return</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>0</td>
      <td>Adjust </td>
      <td>SIZE: word<br>
LINT: long </td>
      <td>fixedlong </td>
      <td>Strips the size word of LINT and converts it into SIZE words.<br>
If not possible: causes integer overflow.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Add</td>
      <td>LINT1: long<br>
LINT2: long </td>
      <td>long</td>
      <td>Returns LINT1 + LINT2.<br>
Can cause overflow if the result is more than 10 words.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Substract </td>
      <td>LINT1: long<br>
LINT2: long</td>
      <td>long</td>
      <td>Returns LINT1 - LINT2.<br>
Can cause overflow if the result is more than 10 words.</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Negate</td>
      <td>LINT: long</td>
      <td>long</td>
      <td>Returns -LINT</td>
    </tr>
    <tr>
      <td>8</td>
      <td>Multiply</td>
      <td>LINT1: long<br>
LINT2: long </td>
      <td>long</td>
      <td>Returns LINT1 * LINT2.<br>
Can cause overflow if the result is more than 10 words.</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Divide</td>
      <td>LINT1: long<br>
LINT2: long </td>
      <td>long</td>
      <td>Returns LINT1 / LINT2.<br>
Can cause overflow or divide-by-zero errors.</td>
    </tr>
    <tr>
      <td>12</td>
      <td>Long to String </td>
      <td>SIZE: word<br>
ADDR: word <br>
LINT: long</td>
      <td>-</td>
      <td>Converts LINT into a string and places it at address ADDR.<br>
SIZE is the maximum number of characters in the string, if it is<br>
exceeded a string-overflow error occurs.</td>
    </tr>
    <tr>
      <td>14</td>
      <td>TOS-1 to Long</td>
      <td>TOS: long<br>
INT: word<br>
      </td>
      <td>TOS: long<br>
RESULT: long <br>
      </td>
      <td>Converts integer INT into a long integer leaving another long
intact
on the top of the stack.</td>
    </tr>
    <tr>
      <td>16</td>
      <td>Compare</td>
      <td>TYPE: word<br>
LINT1: long<br>
LINT2: long</td>
      <td>boolean</td>
      <td>If TYPE = 0, returns LINT1 &lt; LINT2<br>
If TYPE = 1, returns LINT1 &lt;= LINT2<br>
If TYPE = 2, returns LINT1 &gt;= LINT2<br>
If TYPE = 3, returns LINT1 &gt; LINT2<br>
If TYPE = 4, returns LINT1 &lt;&gt; LINT2<br>
If TYPE = 5, returns LINT1 = LINT2</td>
    </tr>
    <tr>
      <td>18</td>
      <td>Int to Long</td>
      <td>INT: word</td>
      <td>long</td>
      <td>Converts integer INT into a long integer.</td>
    </tr>
    <tr>
      <td>20</td>
      <td>Long to Int</td>
      <td>LINT: long</td>
      <td>word</td>
      <td>Converts long integer LINT into an integer.<br>
Can cause overflow if the result doesn't fit in 16 bits.</td>
    </tr>
  </tbody>
</table>
<h4><br>
<br>
<a name="real numbers"></a>Real numbers</h4>
<p>Encoding real numbers in floating point format so they can be
ahndled
by a digital computer is quite a challenge. Not surprisingly, different
people came up with widely different schemes. (Texas Instruments did a
pretty good job with its 8-byte radix 100 format). But p-code is
supposed
to run on any machine, so how can it standardize real numbers?</p>
<p>Well, actually it doesn't! Real numbers calculations are always
performed
in the format used by the machine on which the program runs. The
appropriate
floating point math routines are coded inside the PME.</p>
<p>However, there is still a problem when it comes to program files as
there may be a need to include real constants within a program. To
solve
this problem, the p-system defines two "canonical" formats for
real constants. Whithin a program file, all real-number constants are
grouped
together in a so-called "constant sub-pool". When loading the
program into memory, the p-system converts canonical real numbers into
the format required by the target computer.</p>
<p>For some reasons, there are two canonical formats in p-code: 3-words
reals, and 3-to-6-words reals. They are unfortunately incompatible and
all compilation units in a p-code program must use the same format.
There
is a word in each segment that indicates the real size being used by
this
segment.</p>
<p>The 3-words format is quite simple:</p>
<li>The first word is a signed integer containing the exponent (-32768
to +32767)</li>
<li>The second word is a signed integer from -9999 to +9999 containing
the first 4 mantissa digits, including its sign.</li>
<li>The third word is an integer from 1 to +9999 containing the last 4
mantissa digits, left justified. If this word is negative, it will be
ignored.</li>
<li>The decimal point is assumed to be at the end of the last word in
use
(i.e. the second word if the third is negative, otherwise the third
word).</li>
<li>The digits in the last mantissa word in use are left justified,
i.e.
the word is padded with zeros on the right. (e.g. 11 is coded at 1100,
which is &gt;044C).</li>
<p>The second format, is just an extension of the above one: extra
words
can be added upto a total of 5 mantissa words, to accomodate more
decimal
figures. Just as above, a negative number in words 3 to 5 serves as a
terminator
and all the following words will be omited. The decimal point is always
assumed to be at the end of the last word in use, and the digits in
this
word will be left justified.</p>
<p>Examples:</p>
<pre><u>Real number         Exponent    Mantissa                           <br></u>1234.0                  0        1234   -1<br>-1234.0                 0       -1234   -1 <br>12345678.0              0        1234   5678<br>12345678.0              0        1234   5678   -1 <br>1.234                  -3        1234   -1<br>12.0                   -2        1200   -1<br>12345678.2233          -4        1234   5678   2233   -1<br>111122223333.4444555   -8        1111   2222   3333   44444   5550<br>1.0 E+70               73        1000   -1</pre>
<p>Note the two different ways to code number 12345678: the first one
is
the 3-words format, the next is the 3-to-6 words format (in this case,
it's 4-word long).</p>
<h2>
<hr width="100%"><a name="RSP"></a>The RSP</h2>
<p>RSP stands for Run-time Service Package. It is the part of the PME
that
does not deal directly with interpreting p-codes, but rather handles
various
run-time chores. An important part of it is the RSP/IO that deals with
I/O operations and provides a standardized interface with the
underlying
BIOS.</p>
<p>The RSP/IO implements the concept of "device units". A device
is a peripheral that should be accessed in a standard manner, through a
few predefined operations. Note how this resembles the concept of DSRs
used by TI. </p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#device%20numbers">Devices<br>
</a><b>Procedures<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ioresult">_Ioresult<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitread">_Unitread<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitwrite">_Unitwrite<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitclear">_Unitclear<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitstatus">_Unitstatus<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitbusy">_Unitbusy<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitwait">_Unitwait<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#special%20characters">Special characters<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Subsidiary%20volumes">Subsidiary volumes</a></p>
<h3><br>
<a name="device numbers"></a>Device numbers</h3>
<p>Each device is refered in the p-system with a unique number, from 0
to 255. Some device numbers are pre-assigned by the system:</p>
<pre>0  (reserved)<br>1:  CONSOLE<br>2:  SYSTERM<br>3:  (reserved)<br>4:  DSK1<br>5:  DSK2<br>6:  PRINTER<br>7: &nbsp;REMIN<br>8:  REMOUT<br>9:&nbsp; DSK3<br>10: DSK4<br>11: DSK5<br>12: DSK6<br>13-127: additional disks, subsidiary volumes, user-defined serial devices<br>128-255: user-defined devices.</pre>
<p>Extra units defined in the TI-99/4A p-system implementation:</p>
<pre>14: OS      Card GROMs, contain the system files for the main menu.<br>31: TAPE    Cassette tape recorder.<br>32: TP      Thermal printer.</pre>
<h3><br>
Procedures</h3>
<h4><a name="ioresult"></a>Ioresult</h4>
<p>Most of the procedures describes below will cause a completion code
to be placed in the SYSCOM area, which is an area of memory shared by
the
p-system and the PME. You can retrieve this completion code with the
procedure
IORESULT. The codes are the following:</p>
<p>0: No error<br>
1: Bad block, CRC error<br>
2: Bad device number<br>
3: Illegal I/O request<br>
4: Data-com timeout<br>
5: Volume went off-line<br>
6: File is no longer in directory<br>
7: Illegal filename<br>
8: No room on volume<br>
9: Volume not found<br>
10: File not found<br>
11: Duplicate file<br>
12: Attempt to open an already opened file<br>
13: Attempt to close a file that isn't open<br>
14: Bad format on reading a real or an integer<br>
15: Ring buffer overflow<br>
16: Disk is write-protected<br>
17: Illegal block number<br>
18: Illegal buffer address<br>
19: Bad text file size<br>
20-127: (reserved)</p>
<h4><br>
<a name="unitread"></a>Unitread</h4>
<p>This procedures reads a given number of bytes from a device into a
memory
buffer.</p>
<p>In Pascal, its declaration would look like this:</p>
<pre>PROCEDURE UNITREAD(UNITNUMBER: INTEGER;<br>                   VAR DATA_AREA: PACKED ARRAY[1...NBYTES-1] OF [0...255];<br>                   NBYTES: INTEGER;<br>                   [LBLOCK: INTEGER;]<br>                   [CTRL: INTEGER;] );</pre>
<p>Ok, this is not correct syntax, since Pascal does not allow optional
parameters, nor variable-length arrays, but you get the idea. The
parameters
are the following:</p>
<p><b><tt>UNITNUMBER</tt></b>: the number of the device unit as defined
<a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#device%20numbers">above</a>.<br>
<b><tt>DATA_AREA</tt></b>: A pointer to the buffer where data is to be
stored. This buffer is an array of bytes of length <tt>NBYTES</tt>.
The
pointer is actually made up of two words: a word base and a byte
offset.
Byte-oriented machines just add the two numbers to get the buffer
address.
Word-oriented machines compute the buffer address by indexing byte-wise
from the word base.<br>
<b><tt>NBYTES</tt></b>: Number of bytes to transfer.<br>
<b><tt>LBLOCK</tt></b>: Logical block. This is an optional parameter
used
with disk devices. Each disk is considered as an array of logical
blocks
each 512 bytes in length (If this is not the real format of the disk,
the
BIOS must do the conversion, so that it appears so to the RSP). If this
parameter is not specified, it will be passed as 0.<br>
<b><tt>CTRL</tt></b>: Optional control word parameter, will be 0 if
ommited.
Out of 16 bits, only 7 are currently defined. Note that a given unit
may
use only a few of them.</p>
<pre><font size="+1">UUUr rrrr rrrr CSPA</font></pre>
<ul>
  <p>U = user defined control-bits.<br>
r = r eserved bits.<br>
C = NOCLRF. If this bit is 0, a LF (ascii &gt;0A) will be automatically
appended to each CR (ascii &gt;0D).<br>
S = NOSPEC. If this bit is 1, special characters handling is disabled.<br>
P = PHYSSECT. If this bit is 1, the disk is accessed by physical
sectors
rather than by logical block. In this case, <tt>LBLOCK </tt>contains
the
sector number, and <tt>NBYTES </tt>must be zero. The whole sector
will
be transfered, whatever its size.<br>
A = ASSYNC. If this bit is 1, access will be assynchroneous. This
should
never be the case, so leave this bit as 0.</p>
</ul>
<p><br>
In summary, the stack would look like this before the call:</p>
<pre>          <u>             </u> &lt;  <br>         |<u> Ctrl word   </u>| <br>         |<u> Log Block   </u>|<br>         |<u> Num bytes   </u>|<br>         |<u> Byte offset </u>|<br>         |<u> Word base   </u>|<br>         |<u> Unit number </u>|<br>         |/////////////|</pre>
<p>After the call, all parameters will be poped from the stack by
UNITREAD
itself.</p>
<h4><br>
<a name="unitwrite"></a>Unitwrite</h4>
<p>This procedure writes a given number of bytes to a device. Its
format
is exactly identical to that of UNITREAD.</p>
<h4><br>
<br>
<a name="unitclear"></a>Unitclear</h4>
<p>This procedure is used to reset a device. At the RSP level, this
means
clearing any state flag. The device can then be reset to a known state
by the BIOS, but this is a device-dependent operation. The Pascal
declaration
is:</p>
<pre>PROCEDURE UNITCLEAR(UNITNUMBER: INTEGER);</pre>
<h4><br>
<a name="unitstatus"></a>Unitstatus</h4>
<p>This procedure is intended for a device to report its status into a
buffer that can be upto 30 words in length. The meaning of these words
will depend on the device. The Pascal declaration of <tt>UNITSTATUS </tt>is:</p>
<pre>PROCEDURE UNITSTATUS(UNITNUMBER:&nbsp;INTEGER;<br>                     VAR STATUS_WORDS: ARRAY[0..29] OF INTEGERS;<br>                     CTRL: INTEGER);</pre>
<p><b><tt>UNITNUMBER</tt></b> is the unit number as defined above.<br>
<b><tt>STATUS_WORDS</tt></b> is a pointer to a memory buffer that can
accomodate
upto 30 integers.<br>
<b><tt>CTRL</tt> </b>is control word. Only 1 bit is defined:</p>
<pre><font size="+1">UUUr rrrr rrrr rrrD</font></pre>
<ul>
  <p>U = user defined control-bits.<br>
r = reserved bits.<br>
D = direction. If the bit is 1, the status of the input channel is
queried.
If this bit is 0, the status of the ouput channel is queried.</p>
</ul>
<h4><br>
<a name="unitbusy"></a>Unitbusy</h4>
<p>This procedure was intended for assynchronous environments and will
therefore always return "false" with the TI-99/4A system. Its
Pascal declaration is:</p>
<pre>FUNCTION UNITBUSY(UNITNUMBER: INTEGER): BOOLEAN;</pre>
<h4><br>
<a name="unitwait"></a>Unitwait</h4>
<p>This procedure is intended for assynchronous environments. On the
TI-99/4A
system, it returns immediately and can thus be considered as a NOP. Its
Pascal format is:</p>
<pre>PROCEDURE UNITWAIT(UNITNUMBER: INTEGER);</pre>
<h3><br>
<a name="special characters"></a>Special characters</h3>
<p>As already stated, the main responsability of the RSP/IO is to
handle
communications with the BIOS in a standardized manner. But in addition,
the RSP/IO is also in charge of processing a few special characters:
two
during output (<tt>CR/LF</tt> and <tt>DLE</tt>), and two during input (<tt>EOF
</tt>and <tt>ALPHALOCK</tt>).</p>
<h4>CR / LF</h4>
<p>With the p-system, lines in a text file end with a single <tt>CR </tt>character
(&gt;0D), but this has the meaning of "carriage return, plus line
feed". Many devices consider these two functions as distinct: <tt>CR
</tt>brings the cursor left, while <tt>LF </tt>(ascii &gt;0A) moves
one
line down. The RSP/IO will thus append a <tt>LF </tt>to every <tt>CR
</tt>while
outputing a text file. This behaviour can be suppressed by setting the
NOCRLF bit as 1 in the control word.</p>
<h4>DLE blank compression</h4>
<p>When a text file contains a long stretch of spaces,such as an
indented
line, they are compressed in two bytes: the first one is the <tt>DLE </tt>character
(ascii &gt;10), the second is the number of spaces plus 32 (so as to
make
it a printable character). For instance, a line indented by 8 would
start
with &gt;10 &gt;28. The RSP/IO must decompress such lines and send the
appropriate number of spaces to the BIOS, instead of the <tt>DLE </tt>code.</p>
<h4>EOF</h4>
<p>Several devices, such as CONSOLE, PRINTER or REMIN send a special
character,
called <tt>EOF</tt>, to signal that the end-of-file has been reached.
In
the p-system, <tt>EOF </tt>doesn't have a fixed ascii value. Rather,
it
is a variable stored in the SYSCOM area (a portion of memory shared by
the system and the PME). The RSP/IO must therefore compare each
incoming
character to the one in SYSCOM and, if they match, process it as an <tt>EOF</tt>.
With the TI-99/4A, the value of EOF is generally &gt;83, which
corresponds
to Ctrl-C.</p>
<p>The meaning of an <tt>EOF </tt>depends on the device: for CONSOLE
the
rest of the input buffer will be filled with zeros, for the printer and
remote devices, the <tt>EOF </tt>character is copied into the buffer.
In
any case, input is terminated immediately.</p>
<h4>ALPHALOCK</h4>
<p>Apart for the hardware "alpha-lock" key on the TI-99/4A keyboard,
the p-system also provides a software-based alpha-lock. When the
special
<tt>ALPHALOCK </tt>character is received, all following lower-case
characters
('a' through 'z') will be converted to upper-case. This will continue
until
another <tt>ALPHALOCK </tt>character is received. As with <tt>EOF</tt>,
there is no fixed ascii value for this character, rather it is defined
by a variable in the SYSCOM area (with the TI-99/4A, the ascii value of
this variable is generally &gt;0C, i.e. FCTN-6).</p>
<p>As mentionned above, it is possible to disable the handling of <tt>EOF
</tt>and <tt>ALPHALOCK </tt>by setting the NOSPEC bit to 1 in the
control
word. Note however that this will also disable the handling by the BIOS
of the other special characters (break, start/stop, flush and character
masking).</p>
<h3><br>
<a name="Subsidiary volumes"></a>Subsidiary volumes</h3>
<p>The p-system offers the possibility of creating virtual drives, that
are physically implemented as a partition of an actual drive. These are
called subsidiary volumes. Another responsability of the RSP/IO is to
intercept
calls to a subsidiary volume and to translate them into the appropriate
call to the physical unit on which the subsidiary volume is
implemented.
Concretely, this means changing the unit number and adjusting the block
address. </p>
<p>The SYSCOM memory area contains a unit table with an entry for each
unit in the system. For storage devices, this record contains a
physical
disk unit and a block offset. The RSP/IO looks-up in this table for the
proper unit number to use and adds to block offset to the LBLOCK
parameter
passed by the caller. After some sanity check for absent devices or
illegal
block number, it calls the BIOS with the new values.</p>
<h2><br>
<hr width="100%"><a name="BIOS"></a>The BIOS</h2>
<p>The BIOS (Basic Input Output Subsystem) is of course
machine-specific.
It is in charge of interfacing the computer hardware with the PME via
the
RSP/IO and with p-code programs via the RSP/IO or directly. It retains
the basic definitions of units, but does not have to handle them in a
standardized
manner. </p>
<p>In general, each device driver in the BIOS will handle four
operations:
read, write, control and status. However, the parameters required for
the
corresponding function may vary according to the device.</p>
<p>All BIOS functions should return a completion code to the RSP/IO, so
that it knows if anything went wrong. These codes are a subset of those
that can be returned by the IORESULT routine of the RSP/IO. The
following
codes can be returned by the BIOS:</p>
<p>0: No error<br>
1: CRC error<br>
2: Bad device number (e.g. unimplemented use-defined device)<br>
3: Illegal I/O request<br>
4: Undefined hardware error (not the same as IORESULT)<br>
9: Device not on line (or not implemented in BIOS)<br>
15: Ring buffer overflow<br>
16: Disk is write-protected<br>
17: Illegal block number<br>
18: Illegal buffer address<br>
128-255: Hardware-specific error.</p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Console%20BIOS">Console<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Printer%20BIOS">Printer<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Disk%20BIOS">Disk drives<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Remote%20BIOS">Remote<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Serial%20BIOS">Serial<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#User%20BIOS">User-defined<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#System%20BIOS">System</a></p>
<h3><a name="Console BIOS"></a>Console BIOS</h3>
<p>On the TI-99/4A, the default CONSOLE input channel is the keyboard,
while the default output channel is the screen. Note however that it is
possible to redirect each channel to another device (e.g. output to a
printer
or input from a file).</p>
<h4>CONSOLEREAD</h4>
<p>Only one parameter is needed for reading from the CONSOLE: </p>
<li>The byte to be transfered. This character is not echoed to the
screen
by the BIOS, but by the RSP/IO. </li>
<p>CONSOLE is expected to contain a type-ahead buffer, able to store
from
1 to 32 characters (or more) received from the keyboard until they are
passed to the RSP. If additional characters are entered from the
keyboard
once the buffer is full, the bell should ring.</p>
<p>Optionally, all characters input from the console can be masked with
&gt;7F, as the left-most bit is always 0 in ascci. However, to
accomodate
special characters, it is possible to mask the input with &gt;FF, i.e.
to leave the characters unchanged. The value of the mask is set by the
SETUP utility and stored in the SYSCOM area, an area of memory shared
by
the PME and the p-system.</p>
<p>In addition, the BIOS recognises the following control characters
that
regulates the output channel:</p>
<li><tt>STOP</tt>: suspends ouput to CONSOLE, until another <tt>STOP</tt>,
a <tt>BREAK </tt>or a <tt>FLUSH </tt>character is received, or the
console
is reinitialized. If another <tt>STOP </tt>is received, ouput should
resume
normally from where it stopped. This allows to freeze the screen when
data
scroll up too fast to be read.</li>
<li><tt>FLUSH</tt>: suspends output to CONSOLE and discards all
characters
until another flush or a break character is received, an input from
CONSOLE
is requested, or the console is reinitialized. This allows to quickly
terminate
lengthy output. Note that <tt>FLUSH </tt>has priority over <tt>STOP </tt>(i.e.
has the same effect whether output is frozen or not).</li>
<li><tt>BREAK</tt>: if the NOBREAK flag in the SYSCOM area (value
&gt;40)
is set to 1, nothing happens. Otherwise, this character causes
execution
of a "break" routine whose address is determined at startup time.
Once this routine returns, the BIOS continues as before. Note that the
  <tt>BREAK </tt>character is not passed to the RSP: it is the
responsability
of the "break" routine to inform the RSP about the break.</li>
<h4>CONSOLEWRITE</h4>
<p>Only one parameter is needed for reading from the CONSOLE: </p>
<li>The byte to be displayed. </li>
<p>But the BIOS must also process some characters that have a special
meaning:</p>
<li><tt>CR </tt>(ascii &gt;0D): brings the cursor to the beginning of
the
current line, in column 0.</li>
<li><tt>LF </tt>(ascii &gt;0A): brings the cursor down one line, in
the
same column. If necessary, scrolls the screen up.</li>
<li><tt>BEL </tt>(ascii &gt;07):&nbsp;generates a beep (if possible).</li>
<li><tt>NUL </tt>(ascii &gt;00): causes a delay equal to the time
needed
to output a character, but does not output anything.</li>
<p>Optionally, some additional functions can be offered by the BIOS.
There
is no fixed ascii code for these control characters, their value is
determined
at startup time by entries in the SYSTEM.MISCINFO file.</p>
<li><tt>Move-up</tt>: moves the cursor one line up, in the same column.
If necessary, scrolls the screen down.</li>
<li><tt>Move-left, move-right</tt>: two control characters that move
the
cursor forward or backward respectively, without modifying the text.
The
behaviour at the beginning or the end of the line depends on the device
(normally, the cursor stays where it is).</li>
<li><tt>Home</tt>: moves the cursor to the upper left-hand corner of
the
screen, with no changes to the text.</li>
<li><tt>Move-to</tt>: moves the cursor to an X,Y position without
altering
the text.</li>
<li><tt>Erase to EOL</tt>: erases the current line from the cursor
position
to the end of the line. Leaves the cursor where it is.</li>
<li><tt>Erase to end-of-screen</tt>: erases from the cursor position to
the end of the screen. Leaves the cursor where it is.</li>
<p>The effect of other non-printable characters is not strictly defined
in the p-system specifications.</p>
<h4>CONSOLECTRL</h4>
<p>The CONSOLE initialisation function should be passed two parameters:
</p>
<li>The "break" vector</li>
<li>The SYSCOM pointer</li>
<p>The p-system stores the values for the special characters, the
character
mask, and some flags into an area of memory shared with the PME, called
the SYSCOM area (this area is part of the Kernel segment). Upon
initialisation,
a pointer to SYSCOM is passed to the console BIOS. From this pointer,
the
offsets of the various control characters are the following:</p>
<p>&gt;003A: <tt>NOBREAK</tt> (bit value &gt;40)<br>
&gt;0052: <tt>EOF </tt>character<br>
&gt;0053: <tt>FLUSH </tt>character <br>
&gt;0054: <tt>BREAK </tt>character<br>
&gt;0055: <tt>STOP </tt>character<br>
&gt;005C: Character mask (&gt;7F or &gt;FF)<br>
&gt;005D: <tt>ALPHALOCK </tt>character</p>
<p>Another parameter passed to the console BIOS upon initialisation is
the address of the "break" routine, to be called upon reception
of a <tt>BREAK </tt>character. The console BIOS should store this
address
for further calls.</p>
<p>Upon initialisation, the console BIOS should reset any pending
flushed
or stopped output status and clear the type ahead buffer.</p>
<h4>CONSOLESTAT</h4>
<p>The status routine requires two parameter: </p>
<li>The address of a memory buffer where to report the status</li>
<li>The control word that determines whether the input (1) or output
(0)
channel status is wanted</li>
<p>Only the first status word in the buffer is used:</p>
<ul>
  <p>&gt;0000: Number of characters currently in the input or output
buffer
(depending on the channel tested). If there is no output buffer, this
word
always contain zero. If there is no input buffer this word will be 1 if
a character is ready to be read, 0 otherwise.</p>
</ul>
<h3><br>
<a name="Printer BIOS"></a>Printer BIOS</h3>
<h4>PRINTERWRITE</h4>
<p>Only one parameter:</p>
<li>Byte to print</li>
<p>So as to be as general as possible, the RSP sends characters to the
printer one at a time. If the printer expects characters to be passed
as
whole lines, it is the BIOS job to buffer the characters until an EOL
(end-of-line)
is encountered. Valid EOL characters are: </p>
<li><tt>CR </tt>(ascii &gt;0D): returns the carriage to column 1 but
does
not advance the paper</li>
<li><tt>LF </tt>(ascii &gt;0A): causes the paper to advance to the
next
line. The RSP always sends a <tt>LF </tt>after a <tt>CR</tt>. If the
printer
cannot handle them separately, the BIOS should ignore the <tt>CR </tt>and
perform a "new line" when it receives the <tt>LF</tt>.</li>
<li><tt>FF </tt>(ascii &gt;0C): causes the paper to advance to the top
of the next page and performs a <tt>CR</tt>. If the printer does not
offer
this possibility, the BIOS only performs a new line (i.e <tt>CR </tt>+
  <tt>LF</tt>).</li>
<h4><br>
PRINTERREAD</h4>
<p>Only one parameter:</p>
<li>Byte received</li>
<p>If the printer is able to return data, the BIOS will pass them
directly
to the RSP. Otherwise, input operations result in an error code 3
("illegal
operation").</p>
<h4>PRINTERCTRL</h4>
<p>Upon initialisation, the character buffer is emptied and a new line
(<tt>CR </tt>+ <tt>LF</tt>) is performed. No parameter is passed.</p>
<h4>PRINTERSTAT</h4>
<p>As is the case for the console, the printer status function takes
two
parameters: </p>
<li>A pointer to a memory buffer where status words have to be placed</li>
<li>A control word that determines which channel is to be checked
(1=input
or 0=output)</li>
<p>If the printer has no self-checking abilities, this function just
returns
0. For the output channel, the BIOS returns the number of characters
remaining
to be printed, zero is interpreted by the RSP/IO as a signal that the
printer
is ready to print. A non-zero value indicates that sending a character
to the printer may hang the system until the printer is ready.</p>
<h3><br>
<a name="Disk BIOS"></a>Disk BIOS</h3>
<p>Disks devices are considered by the RSP as a linear array of
512-byte
records. The BIOS is in charge of converting this abstraction to actual
parameters needed for disk access. Note that this feature can be
overriden
by setting the PHYSSECT bit in the control word so that the RSP itself
can do hardware-level operations (i.e. pass the actual sector number).</p>
<h4>DISKREAD</h4>
<p>This function takes five parameters: </p>
<li>The logical block number</li>
<li>The number of bytes to transfer (0 to 32767)</li>
<li>The address of the data buffer</li>
<li>The drive number (0 for DSK1, 1 for DSK2, etc).</li>
<li>The control word as defined in <tt><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitread">UNITREAD</a>
  </tt>in the RSP/IO section.</li>
<p>On input operations, the BIOS will only transfer the required number
of characters, even if this is not a complete sector.</p>
<h4>DISKWRITE</h4>
<p>This function takes the same five parameters as DISKREAD.</p>
<p>For output operations, if the number of bytes sent is not a multiple
of 512, the remaining bytes are undefined. This means that the end of
the
"block" is likely to contain garbage. It is the responsability
of the application program, to know where the valid data ends in the
block.</p>
<h4>DISKCTRL</h4>
<p>Only one parameter is passed:</p>
<li>Drive number</li>
<p>Initialisation brings the drive to a state where it is ready to read
or write. Any buffered data that has not been saved to disk yet will be
lost.</p>
<h4>DISKSTAT</h4>
<p>The status function takes three parameters: </p>
<li>The drive number</li>
<li>A pointer to a memory buffer where status must be reported </li>
<li>A control word the defines which channel is to be tested (1=input,
0=output)</li>
<p>For disks, the status report consists in 4 words:</p>
<ul>
  <p>&gt;0000: the number of bytes currently in the input or output
buffer
(depending on the channel tested)<br>
&gt;0002: the number of bytes per sector.<br>
&gt;0004: the number of sectors per track.<br>
&gt;0006: the number of tracks per disk.</p>
</ul>
<h4>Disk format issues</h4>
<p>The BIOS is in charge of converting the real, physical sectors, into
logical 512-bytes sectors, no matter what the actual sector size may
be.
This may require some tricky buffering if the physical sector size is
greater
than 512 bytes...</p>
<p>Generally, the BIOS will stay away from the first two physical
sectors
on the disk, since these are meant for the boot program. On the
TI-99/4A,
the BIOS fills the whole floppy with one huge file so that all disk
operations
from the p-system translate into file operations for the TI-99/4A DSRs.
The first three sectors on the disk will be occupied by the disk
directory,
the list of file and the file descriptor record (FDR), which leaves 357
sectors of 256 bytes available for the p-system.</p>
<p>Provision was made for the p-system to access physical sectors
directly,
with <tt>DISKREAD </tt>and <tt>DISKWRITE</tt>. To this end, you must
set
bit 1 (weight &gt;02) in the control word. The number of bytes should
be
set as 0 since the whole sector will be transfered, no mater what size
it is. Finally, the physical sector number must be passed as the first
parameter, instead of the logical sector number. (NB The p-system
designers
reserved the right for the "number of bytes" parameter to be
combined with the sector number, so that one could access more than
65536
sectors. Which is why it should be 0 for now).</p>
<p>The correspondance between logical and physical sectors is for you
to
calculate, using the following formula:</p>
<pre>PhysicalSector = (TrackNumber * SectorsPerTrack) + SectorNumber -1</pre>
<pre>TrackNumber = PhysicalSector / SectorsPerTrack</pre>
<pre>SectorNumber = ( PhysicalSector mod SectorsPerTrack) +1</pre>
<p>Where "mod" is the modulo operation, i.e. the remainder of
the rounded division. Note the addition/substraction of 1, due to the
fact
that physical sectors are numbered from one on, whereas logical sectors
are numbered from zero on. No correction is necessary for tracks, since
they are numbered from zero on.</p>
<h3><br>
<a name="Remote BIOS"></a>Remote BIOS</h3>
<p>This device is inteded to be a RS232 serial connection. The BIOS
should
not alter any character during transmission (e.g. not mask the most
significant
bit). The usual transfer rate is 9600 bauds.</p>
<h4>REMOTEREAD</h4>
<p>Single parameter passed:</p>
<li>Byte received</li>
<p>Since they are read one at a time, input characters are buffered as
for the keyboard, in a "type-ahead" buffer.</p>
<h4>REMOTEWRITE</h4>
<p>Only one paramter is needed:</p>
<li>Byte to send</li>
<p>Bytes are sent one at a time by the RSP. The BIOS transmits them as
such.</p>
<h4>REMOTECTRL</h4>
<p>Initialisation brings REMOTE to a state where it is ready to both
send
or receive. No parameter is passed.</p>
<h4>REMOTESTAT</h4>
<p>The status function takes two parameters: </p>
<li>A pointer to a memory buffer where status must be reported. </li>
<li>A control word the defines which channel is to be tested (1=input,
0=output)</li>
<p>Only the first word of the status buffer is used:</p>
<ul>
  <p>&gt;0000: number of characters currently stored in the input (or
output)
buffer.</p>
</ul>
<h3><br>
<a name="Serial BIOS"></a>Serial devices</h3>
<p>For instance, the serial COM port on a PC.</p>
<h4>SERREAD</h4>
<p>Two parameters are passed:</p>
<li>The device number</li>
<li>The byte to be read</li>
<h4>SERWRITE</h4>
<p>Two parameters are passed</p>
<li>The device number</li>
<li>The byte to send</li>
<h4>SERCTRL</h4>
<p>One parameter is used:</p>
<li>Device number</li>
<h4>SERSTAT</h4>
<p>Three parameters are required:</p>
<li>The drive number</li>
<li>A control word the defines which channel is to be tested (1=input,
0=output)</li>
<li>A pointer to a memory buffer where status must be reported </li>
<h3><br>
<a name="User BIOS"></a>User-defined devices </h3>
<p>The BIOS implementation of a user-defined device is left to the
user.
The only requirments is that the function return a completion code when
finished, and that an error code 2 ("illegal unit number") is
returned if the UNITNUMBER parameter does not match any device.
User-defined
devices should have numbers greater than 127.</p>
<h4>USERREAD</h4>
<p>Five parameters are passed to this function. The BIOS can choose to
ignore any of them, of course:</p>
<li>The logical block number</li>
<li>The number of byte to transfer (0 to 32767)</li>
<li>The address of the data buffer</li>
<li>The device number, which corresponds to <tt>UNITNUMBER </tt>in
the
RSP call.</li>
<li>The <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitread">control word</a> as defined by the RSP/IO
(in
  <tt>UNITREAD </tt>and <tt>UNITWRITE</tt>).</li>
<h4>USERWRITE</h4>
<p>This function takes the same parameters as USERREAD.</p>
<h4>USERINIT</h4>
<p>Only one parameter is passed to this function:</p>
<li>Device number</li>
<p>What it does is up to the user.</p>
<h4>USERSTAT</h4>
<p>This function is passed three parameters:</p>
<li>The device number</li>
<li>A pointer to a memory buffer where status must be reported</li>
<li>A control word the defines which channel is to be tested (1=input,
0=output)</li>
<p>What it reports is up to the user that defined the device.</p>
<h3><br>
<a name="System BIOS"></a>System BIOS</h3>
<p>Although the operating system is not an I/O device, the RSP can
still
use the standard I/O function to address the system BIOS. Each function
has a particular meaning:</p>
<h4>SYSREAD</h4>
<p>This function is reserved for future extension. Calling it causes an
HALT (i.e. exits the p-system). Five parameters are passed:</p>
<li>The logical block number</li>
<li>The number of byte to transfer (0 to 32767)</li>
<li>The address of the data buffer</li>
<li>The device number</li>
<li>The <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#unitread">control word</a> for the RSP/IO.</li>
<h4>SYSWRITE</h4>
<p>Reserved for future extension. Causes an HALT (i.e. exits the
p-system).
The same five parameter are used than with SYSREAD.</p>
<h4>SYSCTRL</h4>
<p>The function is passed two parameters:</p>
<li>The device number</li>
<li>The EVENT vector</li>
<p>Resets the clock value as &gt;00000000.</p>
<h4>SYSSTAT</h4>
<p>Two parameters are required:</p>
<li>A pointer to a memory buffer where status must be reported </li>
<li>The control word </li>
<p>Returns 3 words in the status buffer:</p>
<ul>
  <p>&gt;0000: Address of the last word (not the last byte! This must
be
an even address) of RAM accessible for the system. <br>
&gt;0002: The least significant word of a 32-bit time value. If not
clock
is implemented, this word is 0. Otherwise, it contains the number of
1/60th
of seconds since initialisation.<br>
&gt;0004: The most significant word of the time value or zero if the
internal
clock in not implemented.</p>
</ul>
<h2><br>
<br>
<hr width="100%"><a name="OS"></a>The Operating system</h2>
<p>The operating system is in charge of loading and running p-code
programs
in the host machine. One of its main tasks is to react to segment
faults:
each time the p-code program calls a segment that is not currently in
memory,
a segment fault is issued. The p-system kicks in, loads the required
segment
in the code pool, (possibly shifting other segment to make room, or
even
trashing one), then it returns control to the p-code program.</p>
<p>The p-system manages a special memory stack, called the heap, for
its
internal use. Under some circonstances, the user can also store data on
the heap.</p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#system%20units">System units<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Code%20pool">Code Pool<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Faults">Faults<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Heap">Heap<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SIB">SIBs<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#E_Rec">E-Recs and E-Vects<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Tasks">Tasks<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Syscom%20area">Syscom area<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#File%20access">File access</a></p>
<h3><br>
<a name="system units"></a>System compilation units</h3>
<p>The p-system is written in Pascal. It consists in the following
compilation
units:</p>
<table cellspacing="0">
  <tbody>
    <tr>
      <th align="left" height="10%">Units</th>
      <th align="left">Usage</th>
    </tr>
    <tr>
      <td>HEAPOPS<br>
EXTRAHEAP<br>
PERMHEAP </td>
      <td>Heap operations</td>
    </tr>
    <tr>
      <td>SCREENOPS</td>
      <td>Screen operations</td>
    </tr>
    <tr>
      <td>FILEOPS</td>
      <td>File and directories operations</td>
    </tr>
    <tr>
      <td>PASCALIO<br>
EXTRAIO<br>
SOFTOPS</td>
      <td>File-level I/O</td>
    </tr>
    <tr>
      <td>SMALLCOMMAND <br>
COMMANDIO</td>
      <td>I/O redirection and chaining</td>
    </tr>
    <tr>
      <td>STRINGOPS</td>
      <td>String operations</td>
    </tr>
    <tr>
      <td>OSUTILS</td>
      <td>Conversion utilities</td>
    </tr>
    <tr>
      <td>CONCURRENCY</td>
      <td>Concurrency management</td>
    </tr>
    <tr>
      <td>REALOPS</td>
      <td>Floating point operations, real numbers I/O</td>
    </tr>
    <tr>
      <td>LONGOPS</td>
      <td>Long integer operations</td>
    </tr>
    <tr>
      <td>GOTOXY</td>
      <td>Screen cursor control (may be user-supplied)</td>
    </tr>
    <tr>
      <td>KERNEL </td>
      <td>Resident part of the OS (segment 0). Code pool maintenance,
fault handling,
segments loading.</td>
    </tr>
    <tr>
      <td><font size="-1">GETCMD</font></td>
      <td>Subsidiary segment of KERNEL ( swappable). Processes user
input, builds
run-time environment.</td>
    </tr>
    <tr>
      <td><font size="-1">USERPROG</font></td>
      <td>Ditto. Contains user program (at power-up: builds the initial
environment).
Segment 15.</td>
    </tr>
    <tr>
      <td><font size="-1">INITIALIZE</font></td>
      <td>Ditto. Processes SYSTEM.MISCINFO, locates code files, builds
the device
table.</td>
    </tr>
    <tr>
      <td><font size="-1">PRINTERROR</font></td>
      <td>Ditto. Prints run-time error messages.</td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Code pool"></a>Code pool</h3>
<p>The code pool is where p-code segments are placed for execution. It
is managed by the system which can move or unload segments if more room
is needed. The system always keeps the loaded segment as a continous
block
in memory. When new segments are loaded, they are appended at the end
of
this area. Note that assembly language segments, which are not
relocatable,
are not placed in the code pool , but rather on the heap.</p>
<p>Depending on the machine, the code pool can be placed in between the
stack and the heap (internal pool), or have a memory area for itself
(external
pool). I'm not sure which is the case for the TI-99/4A.</p>
<p>The following variables are used by the code-pool management
routines:</p>
<p><b>SP_Low</b>: Only relevant for an internal pool. Pointer to the
lowest
possible bound of the stack, i.e. one word above the top of an internal
code pool. SP_Low is located in the TIB (Task Information Block).</p>
<p><b>HeapTop</b>. Only relevant for an internal pool. Pointer to the
top
of the heap. HeapTop is part of the HeapInfo record.</p>
<p><b>Seg_Pool</b>. Pointer to the Pool_Descriptor. Seg_Pool is part of
the <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SIB">SIB</a> (Segment Information Block).</p>
<p>The Pool_Descriptor comprises the following fields:</p>
<pre>Record<br>  PoolBase   : fulladdress;<br>  PoolSize   : integer;<br>  MinOffset  : memptr;<br>  MaxOffset  : memptr;<br>  Resolution : integer;<br>  PoolHead   : SIB_Ptr;<br>  Perm_SIB   : SIB_Ptr;<br>  Extended   : boolean;<br>end;</pre>
<p><b>PoolBase</b> is a 32-bits address that points at the base of the
code pool.<br>
<b>PoolSize</b> is the size in words of the code pool. Set by the SETUP
utility.<br>
<b>MinOffset</b> is the lower boundary of the code pool.<br>
<b>MaxOffset</b> is the upper boundary of the code pool. Same as SP_Low
for an internal pool.<br>
<b>Resolution</b> is the offset in bytes for segment alignment, set in
SYSTEM.MISCINFO. Segments always start at an address which is a
multiple
of this number.<br>
<b>PoolHead</b> points at the SIB at the base of the code pool.<br>
<b>Perm_SIB</b> points at a SIB that is always resident (currently
GOTOXY).<br>
<b>Extended</b> is TRUE if extended memory is used. Set in
SYSTEM.MISCINFO.</p>
<p>When a segment fault occurs, the pool managment routines must load
the
required segment(s) before returning to the PME. The routines
successively
try to:. </p>
<li>Load the segment at either end of the code pool. </li>
<li>If the pool is internal, shift it towards the stack (or the heap),
to try to make room at the other end. The pool can be moved all the way
to the heap, but never closer than 40 words from the top of the stack.</li>
<li>Swap out swappable segments and group the others together, to make
room for the incoming segment(s).</li>
<li>If even this fails, report a stack overflow, and reinitialize the
system.</li>
<p>With an internal code pool, the managment routines must also respond
to stack fault and heap faults. To free the necessary space, the
routines
try to:</p>
<li>Move the pool toward the stack, to free the required number of
words
for the heap (or conversely).</li>
<li>Swap out one or more swappable segment(s), compact the others
together
and shift the pool towards the stack (or heap).</li>
<li>If this does not work, report a stack overflow and reinitialized
the
system.</li>
<h3><br>
<a name="Faults"></a>Fault handling</h3>
<p>There is a high priority task called FaultHandler in the OS, whose
job
is to handle memory fault. This process is started at boostrap time,
but
immediately waits for a semaphore. When a routine detects a fault it
just
signals the semaphore and FaultHandler takes over. FaultHandler deals
with
the fault (hopefully), then resumes waiting for the semaphore, which
returns
control to the faulty task.</p>
<p>The semaphore resides in the SYSCOM area and is declared as:</p>
<pre>Fault_Message = RECORD<br>                 Fault_TIB  : TIB_Ptr;<br>                 Fault_E_Rec: E_Rec_Ptr;<br>                 Fault_Words: integer;<br>                 Fault_Type : SegFault..Pool_Fault;<br>                END;</pre>
<pre>Fault_Sem: RECORD<br>            Real_Sem, Message_Sem: semaphore;<br>            Message: Fault_Message;<br>           END;</pre>
<p>As you may have guessed, the record "Message" is used by the
routine that generated the fault to pass information to FaultHandler.
The
contents of this record is pretty much self-explanatory, but just in
case:</p>
<p><b>FaultType</b> indicates the type of fault (segment, stack, heap,
pool, etc).<br>
<b>TIB_Ptr</b> points to the Task Information Block of the faulting
task.<br>
<b>Fault_E_Rec</b> points to the Environment record of the current
segment
or of the missing segment (for segment faults).<br>
<b>Fault_Words</b> is the number of words needed (e.g. for stack
faults).
It's 0 for segment faults.</p>
<p>Faults can be signaled either by the PME or by the OS itself. The
PME
detects only stack and segment faults, which have been described in
more
details in the relevant <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Faults&amp;errors">chapter</a>.</p>
<p>The OS routes all faults through the EXECERROR routine. It can issue
a segment fault in only one occasion: when you try to use MEMLOCK to
lock
a segment that's not in memory. It can also issue heap faults, when you
are using MARK, NEW, VARNEW or PERMNEW and there isn't enough memory on
the heap.</p>
<p>As discussed above, FaultHandler then tries to move around segments
in the code pool, and free some memory. When doing this, it must of
course
make sure that the current segment will not be swapped out of memory!
In
case of a stack fault created by calling a routine in a different
segment,
both segments must be locked in memory.</p>
<h3><br>
<a name="Heap"></a>The Heap</h3>
<p>The heap is a separate stack used by the OS for its own purposes.
Typically,
the heap and the stack grow toward each other in memory, possibly with
the code pool in between them. Which means that stack faults, and
possibly
segment faults, can affect the amount of memory available for the heap.
Conversely, the heap management routines can issue a heap fault to
request
additional space. </p>
<p>The heap managment routines are the following:</p>
<h4>MARK();</h4>
<p>Saves the location of the top-of-heap.</p>
<h4>RELEASE()</h4>
<p>Cuts the heap at the position of the corresponding MARK, discarding
any variable located in this space (except those declared with
PERMNEW).
MARK and RELEASE can be nested, and care should be taken to match them
properly.</p>
<h4>NEW(PTR: TYPE)</h4>
<p>Allocates room for a variable on top of the heap. PTR is a pointer
to
a variable type, which allows NEW to know how many words should be
reserved.
If TYPE has variants, NEW&nbsp;allocates enough space for the largest
variant,
unless instructed otherwise.</p>
<h4>DISPOSE(PTR: TYPE)</h4>
<p>De-allocates the space reserved by NEW for the variable pointed by
PTR.
Afterwards, PTR&nbsp;will contain NIL. If a specific variant of TYPE
was
requested with NEW, then it should also be requested in the
corresponding
DISPOSE.</p>
<h4>VARNEW(PTR: TYPE; NWORDS: word): word</h4>
<p>Allocates NWORDS words on top of the heap and places the address of
the first one in the variable pointed by P. Returns the number of words
effectively allocated which should be equal to NWORDS, or to zero if
there
wasn't enough space.</p>
<h4>VARDISPOSE(PTR: TYPE; NWORDS: word)</h4>
<p>De-allocates NWORDS words from the position pointed at by PTR and
places
NIL in PTR. It's extremely important that NWORDS has the exact same
value
than was unsed in the corresponding VARNEW call. </p>
<h4>PERMNEW(PTR: TYPE)</h4>
<p>Allocates memory for a variable just like NEW, but this space can
only
be reclaimed with PERMDISPOSE: even RELEASE won't destroy it. This
function
is reserved for internal use by the OS (e.g to chain programs, so that
the next command is still available after a program has released its
heap
allocation).</p>
<h4>PERMDISPOSE(PTR:TYPE)</h4>
<p>This is the only way to de-allocate space reserved by PERNEW. Again,
this procedure is reserved for system use.</p>
<p>These procedures are located in three compilation units:</p>
<p>HEAPOPS contains MARK, RELEASE and NEW.<br>
EXTRAHEAP contains DISPOSE, VARNEW , VARAVAIL, MEMLOCK and MEMSWAP.<br>
PERMHEAP contains PERMNEW, PERMDISPOSE and PERMRELEASE.</p>
<h3><br>
Heap management</h3>
<p>The heap is managed by placing marks on it. There are two types of
marks:</p>
<li>Marks placed by the MARK routine and used by RELEASE to cut the heap</li>
<li>Marks placed by NEW and VARNEW to reserve heap space for data.</li>
<p>Both types of mark share the common type MemLink:</p>
<pre>TYPE<br> MemLink = RECORD<br>            Avail_list: MemPtr;<br>            NWords: integer;<br>            CASE Boolean OF<br>              true: (Last_Avail, Prev_Mark : MemPtr);<br>           END</pre>
<p>With MARKed marks, the variant is true, and we have the following
fields:</p>
<p><b>NWords</b> is always 0 because these marks do not reserve any
space.
<br>
<b>Prev_Mark</b> points to the previous mark down the heap.The bottom
mark
has NIL in this field and the topmost mark is pointed at by the global
variable HeapInfo.TopMark. This allows to easily walk the whole chain
of
marks on the heap, for instance to remove a mark with RELEASE.<br>
<b>Last_Avail</b> points to the top of the available space above the
mark.
Typically, this space will be bound by the next mark, or by an
allocated
variable (or by the code pool, in the case of the topmost mark on the
heap).<br>
<b>Avail_list</b> points to a list of data marks, created by either NEW
or VARNEW. The first record in this list constitues the lowest
unallocated
space above the mark.</p>
<p><br>
With data marks, the variant field is false, so Last_Avail and
Prev_Mark
don't exist:</p>
<p><b>NWords</b> is the amount of space reserved for the variable,
including
the two words occupied by the mark record itself. <b>Avail_list</b>
points
to the memory-reserving mark for the next variable.</p>
<h4><br>
Global variables</h4>
<p><b>HeapInfo</b> is an important variable used for heap maintenance.
It has the following structure:</p>
<pre>VAR<br> HeapInfo: RECORD<br>            Lock: semaphore;<br>            Topmark, HeapTop: MemPtr;<br>           END</pre>
<pre> PermList: MemPtr;</pre>
<p><b>Lock </b>is a semaphore used by heap-modifying routines, to make
sure that the heap will only be modified by one process at a time. <br>
<b>TopMark</b> point to the topmost mark installed by the MARK
subroutine,
as described above.<br>
<b>HeapTop</b> points at the highest allocated space on the heap. It is
used by FaultHandler to determine how close the heap is from the stack
(or from the code pool, if it's placed in between the heap and the
stack).</p>
<p><b>PermList </b>is another variable used for heap management. It
points
at the top of a separate list of memory-reserving marks used uniquely
for
variables allocated by PERMNEW. PermList can be NIL if no variable was
allocated with PERMNEW.</p>
<p><u>Example:</u></p>
<p>Here is a example of heap structure. It contains three MARKed marks
(red) linked together through their Prev_Mark fields (red arrows). In
each,
the Last_Avail field points to the highest portion of the heap that
they
are allowed to use for their data marks (black arrows).</p>
<p>The top mark's chain of data mark consist in only one mark, that
reserves
space for the integer Dummy.</p>
<p>The bottom mark does not point to any data chain any more, but there
is some free space above it, indicating that some data may have been
there,
but disposed of.</p>
<p>The middle mark point to a chain of data marks (blue) linked
together
by their Avail_List fields (blue arrows). In this case, the chain
contains
only two data marks, that reserve memory for the integer Foo, and the
3-word
long-integer Bar, respectively. Note that here also, there is some
empty
space between Foo and Bar, where variables may have been allocated,
then
disposed of.</p>
<pre>:                  :<br>| STACK or CODE    |<br>+------------------+ &lt;---,     <br>| //////////////// |     |<br>| //////////////// |     |<br>+------------------+     |  &lt;---HeapInfo.HeapTop<br>| Int: Dummy       |     |<br>+------------------+     |<br>|<font color="#0000ff"> Avail_List = NIL</font> |     | <br>| <font color="#0000ff">NWords = 1  </font>     |     | <br>+------------------+<font color="#0000ff"> &lt;-,</font> |    <br>| <font color="#ff0000">Avail_List</font>  <font color="#0000ff">-----</font>|<font color="#0000ff">---'</font> |<br>| <font color="#ff0000">NWords = 0 </font>      |     |<br>| <font color="#ff0000">Last_Avail</font>  -----|-----' <br>| <font color="#ff0000">Prev_Mark</font> <font color="#ff0000">  -----</font>|<font color="#ff0000">-------,<br></font>+------------------+       <font color="#ff0000">|&lt;---HeapInfo.TopMark<br></font>| Long: Bar        |       <font color="#ff0000">|<br></font>| ( 3 words )      |       <font color="#ff0000">|<br></font>+------------------+       <font color="#ff0000">|<br></font>| <font color="#0000ff">Avail_List = NIL</font> |       <font color="#ff0000">|<br></font>| <font color="#0000ff">NWords = 3</font>       |       <font color="#ff0000">|<br></font>+------------------+<font color="#0000ff">&lt;-,</font><font color="#000000">&lt;-,</font> <font color="#ff0000">|<br></font>| //////////////// |  <font color="#0000ff">|</font>  | <font color="#ff0000">|<br></font>+------------------+  <font color="#0000ff">|</font>  | <font color="#ff0000">|<br></font>| Int: Foo         |  <font color="#0000ff">| </font> | <font color="#ff0000">|<br></font>+------------------+  <font color="#0000ff">| </font> | <font color="#ff0000">|<br></font>| <font color="#0000ff">Avail_List</font>  <font color="#0000ff">-----</font>|<font color="#0000ff">--' </font> | <font color="#ff0000">|<br></font>| <font color="#0000ff">NWords = 1 </font>      |     | <font color="#ff0000">|<br></font>+------------------+<font color="#0000ff">&lt;-,</font>  | <font color="#ff0000">|<br></font>| <font color="#ff0000">Avail_List</font>  <font color="#0000ff">-----</font>|<font color="#0000ff">--'</font>  | <font color="#ff0000">|<br></font>| <font color="#ff0000">NWords = 0</font>       |     | <font color="#ff0000">|<br></font>| <font color="#ff0000">Last_Avail</font>  -----|-----' <font color="#ff0000">|<br></font>| <font color="#ff0000">Prev_Mark</font>   <font color="#ff0000">-----</font>|<font color="#ff0000">----,</font>  <font color="#ff0000">|<br></font>+------------------+&lt;-, <font color="#ff0000">|&lt;-'<br></font>| //////////////// |  | <font color="#ff0000">|<br></font>+------------------+  | <font color="#ff0000">|</font> <br>| <font color="#ff0000">Avail_List = NIL</font> |  | <font color="#ff0000">|</font> <br>| <font color="#ff0000">NWords = 0 </font>      |  | <font color="#ff0000">|<br></font>| <font color="#ff0000">Last_Avail</font>  -----|--' <font color="#ff0000">|<br></font>| <font color="#ff0000">Prev_Mark = NIL</font>  |    <font color="#ff0000">|<br></font>+------------------+<font color="#ff0000">&lt;---'</font>
</pre>
<h4><br>
Heap managment tactics</h4>
<p>HeapTop is set to point at the new top of heap, as soon as space on
top of the heap is requested by one of the heap management routines.
This
way, if a stack fault occurs, there won't be any conflict between these
routines and FaultHandler.</p>
<p>The OS uses the heap for its own purposes, but the heap is also
available
for your programs. To avoid conflicts, the system puts a mark on the
heap
( called EMPTYHEAP) after your program's runtime environment has been
built,
but before the program is actually started. Once the program
terminates,
the system releases EMPTYHEAP, therefore destroying anything you may
have
placed on the heap (unless you used PERMNEWs, which you shouldn't).
Note
that your program's SIBs, E_Recs and E_Vects are part of the run-time
environment
and will therefore appear before the EMPTYHEAP mark. So do global data
in your program, and in any units it uses.</p>
<p>Among other things, the OS maintains a disk directory on the heap.
It
is pointed at by the global variable SysCom^.GDirP, but it is meant to
be invisible for you. So before any heap operation (except DISPOSE),
the
system will remove this directory with DISPOSE and make its space
available
again.</p>
<h3><br>
<a name="SIB"></a>SIB: Segment Information Blocks</h3>
<p>A segment is considered active if it may be used by the current
program,
whether it is currently loaded in memory or still on disk. Each active
segment is described in a Segment Information Block (SIB) on the heap.
When a program requires a segment that is not yet active, an SIB is
created
for it on the heap. All SIBs are arranged in a double-linked list and
reference
each others via their Prev_SIB and Next_SIB fields.</p>
<p>The structure of a SIB is the following:</p>
<pre>RECORD<br> Seg_Pool   : ^Pool_Des;<br> Seg_Base   : memptr;<br> Seg_Refs   : integer;<br> Time_Stamp : integer;<br> Link_Count : integer;<br> Residency  : -1...maxint;<br> Seg_Name   : PACKED ARRAY [0..7] OF CHAR;<br> Seg_Leng   : integer;<br> Seg_Addr   : integer;<br> Vol_Info   : VIP;<br> Data_Size  : integer;<br> Res_SIB    : RECORD<br>               Next_SIB : SIB_Ptr;<br>               Prev_SIB : SIB_Ptr;<br>               CASE boolean OF<br>                 TRUE: Next_Sort: SIB_Ptr;<br>                 FALSE: New_Loc: memptr;<br>              END<br> M_Type    : integer;<br>END</pre>
<p><b>Seg_Pool</b> points to the Pool_Descriptor for the pool in which
the segment resides. If the segment is on the heap (as is the case for
non-relocatable segments) or if there is no external code pool,
Seg_Pool
is NIL.<br>
<b>Seg_Base</b> contains the byte offset of the segment within the code
pool, or the address of the segment on the heap. If the segment is not
in memory, Seg_Base is NIL.<br>
<b>Seg_Refs</b> contains the number of outstanding calls to the
segment.
It is incremented each time a routine in the segment is called by an
external
segment, it is decremented when this routine returns to its external
caller.<br>
<b>Time_Stamp</b> is used by the system to determined which segment is
the least recently used, when segments should be swapped out to make
room
in the code pool. The <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Syscom%20area">Syscom area</a>
contains a
16-bit variable that is incremented every time a segment is exited.
This
variable is copied in the Time_Stamp field of the segment exited.<br>
<b>Link_Count</b> indicates how many external variables reference the
SIB.
The operating system uses several such variables, including the
Prev_SIB
and Next_SIB fields of other SIBs. Link_Count is incremented each time
a pointer is set to the SIB and decremented when this pointer is
destroyed.
When Link_Count becomes zero, the SIB is removed from the heap.<br>
<b>Residency</b> is 0 for segments that are swappable. Values greater
than
zero indicate that the segment is locked in memory. Residency is
incremented
each time a program locks the segment (with the MEMLOCK function), and
decremented each time it is unlocked (with the MEMSWAP function). A
value
of -1 indicates a segment that was position-locked at loading time and
cannot be made swappable.<br>
<b>Seg_Name</b> contains the first 8 characters of the segment name.<br>
<b>Seg_Len</b> is the number of code words in the segment, including
the
relocation lists but not the reference lists.<br>
<b>Seg_Addr</b> contains the number of the segment's first block on
disk.<br>
<b>Vol_Info</b> points to a volume information record that contains the
drive number and diskname for the disk where the segment resides.<br>
<b>Data_Size</b> is the number of data words in the code segment's data
segment. This only applies to principal segments (for others Data_Size
is 0).<br>
<b>Res_SIB</b> is used to maintain the code pool by waking the list of
SIBs. Its Prev_SIB field points to the previous SIB in the list,
Next_SIB
points to the next SIB in the list. An extra field is used by the code
pool management routine to store temporary values: either Sort_SIB or
New_Loc.</p>
<h3><br>
<a name="E_Rec"></a>E_Rec and E_Vect</h3>
<p>Many p-code instructions require a segment number as an argument.
For
instance, <tt>CXL 12,3</tt> calls procedure number 3 in segment 12.
However,
there is no such thing as a library of all existing segments and their
corresponding numbers. In fact, only one segment has a fixed number:
KERNEL,
which is segment number 0. For all others, the compiler assigns each
segment
an arbitrary number, from 2 to 255 (number 1 is reserved for the
current
segment). This may be a problem when trying to link units that were
compiled
independently: the same segment may have been given completely
different
numbers during the various compilations.</p>
<p>Rather than having the linker patch the code to match the segment
numbers,
the p-system designers went for a more flexible solution. Firstly, the
compiler appends a segment reference list to the codefile it creates.
This
is a list of segment names, together with the numbers that the compiler
has assigned to them. Then, when the file is loaded, the system creates
an environment vector (or E_Vect) for each segment. An E_Vect is just
an
array of pointers to other segments. This way, the segment numbers used
by the p-codes are just indexes into the E_Vect. To find the relevant
segment,
the PME just reads the pointer found at a given position in the E_Vect.</p>
<p>The structure of an E_Vect is the following:</p>
<pre>RECORD<br> Vec_Length : integer;<br> Map        : array [1..Vec_Length] of ^E_Rec;<br>END</pre>
<p><b>Vec_Length</b> indicates the number of entries in the E_Vect,
i.e.
the number of segments it references (including itself).<br>
<b>Map</b> is an array of pointers to other segments, arranged
according
to the segment numbers assigned at compilation time.</p>
<p>If you thought that the pointers in the E_Vect would point at other
segments' SIBs, you were wrong. They point at special stuctures, called
"Environment Records" or E_Rec. Each segment has an E_Rec, that
contains pointers to important structures in this segment. The
structure
of an E_Rec is the following:</p>
<pre>RECORD<br> Env_Data : memptr;<br> Env_Vect : ^E_Vect;<br> Env_SIB  : ^SIB;<br> CASE boolean OF<br>  TRUE: ( Link_Count : integer;<br>          Next_Rec   : ^E_Rec;<br>         )<br>END</pre>
<p><b>Env_Data</b> points at this segment's global data, allocated on
the
heap when the program is executed.<br>
<b>Env_Vect</b> points at this segment's E_Vect, an array of pointers
to
other segments' E_Recs.<br>
<b>Env_SIB</b> points at this segment's <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SIB">SIB</a>, which
is
allocated on the heap when the program is executed.<br>
The next two fields are only present in the E_Rec of the principal
segment
in a compilation unit:<br>
<b>Link_Count</b> indicates the number of other units that are using
this
principal segment.<br>
<b>Next_Rec</b> is used to maintain a chain of all active compilation
units.
It points to the next unit in the chain.</p>
<p><u>Example:</u></p>
<p>Let's use three segments, "Tic", "Tac" and "Toe".
Tic is a principal segment that references Tac and Toe. Toe is a
principal
segment in another compilation unit, it also references Tac. Tac is a
subsidiary
segment, it does not reference any other segment. Note that each
segment
has an entry for itself in the E_Vect, but I omited these arrows, for
clarity.</p>
<pre>     "Tic" E_Rec<br>   +------------+<br>   | <font color="#ff0000">Env_Data</font>   |      E_Vect   1     2     3<br>   +------------+      +-----+-----+-----+-----+<br>   | <font color="#ff0000">Env_Vect</font>   |<font color="#000000">-----&gt;</font>|  <font color="#000000">3</font>  | <font color="#ff0000">Tic</font> | <font color="#00ff00">Toe</font> | <font color="#0000ff">Tac</font> |<br>   +------------+      +-----+-----+--<font color="#00ff00">|</font>--+--<font color="#0000ff">|</font>--+<br>   | <font color="#ff0000">Env_SIB</font>    |                     <font color="#00ff00">|</font>     <font color="#0000ff">|</font>        <br>   +------------+                     <font color="#00ff00">|</font>     <font color="#0000ff">|<br></font>   | <font color="#ff0000">Link_Count</font> |           <font color="#0000ff">,---------</font><font color="#00ff00">|</font><font color="#0000ff">-----'<br></font>   +------------+           <font color="#0000ff">|</font>         <font color="#00ff00">|</font> <br><font color="#ff0000">,--</font>| <font color="#ff0000">Next_Rec</font>   |           <font color="#0000ff">|</font>         <font color="#00ff00">|</font> <br><font color="#ff0000">|</font>  +------------+           <font color="#0000ff">|</font>         <font color="#00ff00">|</font>   <br><font color="#ff0000">|</font>                           <font color="#0000ff">|</font>         <font color="#00ff00">'-----,</font> <br><font color="#ff0000">|</font>  <font color="#0000ff">,------------------------'</font>               <font color="#00ff00">|</font>          <br><font color="#ff0000">|</font>  <font color="#0000ff">|</font>                                        <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  <font color="#0000ff">+----------------------------------,</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  <font color="#0000ff">|</font>                                  <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  <font color="#0000ff">V</font>  "Tac" E_Rec                     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  +------------+                     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  | <font color="#0000ff">Env_Data</font>   |      E_Vect   1     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  +------------+      +-----+-----+  <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  | <font color="#0000ff">Env_Vect</font>   |-----&gt;|  <font color="#000000">1</font>  | <font color="#0000ff">Tac</font> |  <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  +------------+      +-----+-----+  <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  | <font color="#0000ff">Env_SIB</font>    |                     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  +------------+                     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>                                     <font color="#0000ff">|</font>     <font color="#00ff00">|<br></font><font color="#ff0000">|</font>  <font color="#00ff00">,----------------------------------</font><font color="#0000ff">|</font><font color="#00ff00">-----'<br></font><font color="#ff0000">|</font>  <font color="#00ff00">|</font>                                  <font color="#0000ff">|<br></font><font color="#ff0000">|</font>  <font color="#00ff00">V</font>  "Toe" E_Rec                     <font color="#0000ff">|<br></font><font color="#ff0000">'-&gt;</font>+------------+                     <font color="#0000ff">|<br></font>   | <font color="#00ff00">Env_Data</font>   |      E_Vect         <font color="#0000ff">|<br></font>   +------------+      +-----+-----+--<font color="#0000ff">|</font>--+<br>   | <font color="#00ff00">Env_Vect</font>   |-----&gt;|  <font color="#000000">2</font>  | <font color="#00ff00">Toe</font> | <font color="#0000ff">Tac</font> |<br>   +------------+      +-----+-----+-----+<br>   | <font color="#00ff00">Env_SIB</font>    |               1     2 <br>   +------------+<br>   | <font color="#00ff00">Link_Count</font> |<br>   +------------+<br>   | <font color="#00ff00">Next_Rec =0</font>|<br>   +------------+  </pre>
<p>Note that Tac is referenced as segment number 2 in Toe , but as
segment
number 3 in Tic. Therefore, the instruction<br>
CXL Tac,5 (which calls procedure 5 in Tac ) will be compiled as &gt;93,
&gt;03, &gt;05 in Tic, but as &gt;93, &gt;02, &gt;05 in Toe. </p>
<p>When executing CXL Tac,5 in the segment Tic, the PME reads &gt;93,<b>&gt;03</b>,&gt;05,
gets the third enty in Tic's E_Vect and obtains a pointer to Tac's
E_Rec.
Then it locates procedure number 5 in Tac and branches to it.</p>
<p>Similarly, when encountering a CXL Tac,5 in segment Toe (which is
coded
&gt;93,<b>&gt;02</b>,&gt;05), the PME gets entry number 2 in Toe's
E_Vect,
which is again a pointer to Tac. You get the idea?</p>
<p>Finally, note the chaining between the principal segments: Tic's
Nec_Rec
points to Toe (red arrow). The corresponding entry for Toe is NIL,
since
Toe is at the end of the list in our example.</p>
<h3><br>
<a name="Tasks"></a>Tasks</h3>
<p>The p-system is a multitasking operating system. That's right, it
turns
your TI-99/4A into a multitasking machine! </p>
<p>A task can be seen as a "line of execution" of a program.
At any time there can only be one task running (since the TI-99/4A only
has one processor), but there can be many more tasks pending. The
p-system
achieves multitasking by quickly switching from one task to the next,
providing
the illusion that all tasks run at the same time.</p>
<p>The "main task" is the thread of execution that starts the
p-system, runs any utility or user program, then exits the p-system.
Anywhere
in this thread, subsidiary tasks can be launched that will execute
"concurently"
with the main task.</p>
<p>Three things are required for multitasking: </p>
<ol>
  <li>The task(s) body, i.e. the routine(s) that must run in this task,
and
its associated data. </li>
  <li>A TIB, or Task Information Block, into which the p-system saves
values
critical for the task. </li>
  <li>A task queue used by the p-system to schedule the next task.
There
may be several queues: one for the tasks ready to run and one for each
semaphore (whether there are tasks waiting for it or not).</li>
</ol>
<h4><a name="TIB"></a>TIB: Task Information Blocks</h4>
<p>A TIB is a structure allocated on the heap into which the p-system
saves
some critical values from the present task, before it switches to
another.
For instance, it saves the current instruction pointer (IPC) and most
of
the other p-machine registers. These values will be restored when the
system
switches back to this task.</p>
<p>The structure of a TIB is the following:</p>
<pre>RECORD<br> Regs: PACKED RECORD<br>        Wait_Q      : ^TIB;<br>        Prior       : byte;<br>        Flags       : byte;<br>        SP_Low      : memptr;<br>        SP_Upr      : memptr;<br>        SP          : memptr;<br>        MP          : ^MSCW;<br>        Reserved    : integer;<br>        IPC         : integer;<br>        Env         : ^E_Rec;<br>        Proc_Num    : byte;<br>        TI_BIOResult: byte;<br>        Hang_Ptr    : ^Sem;<br>        M_Depend    : integer;<br>      END<br> Main_Task  : Boolean;<br> Start_MSCW : ^MSCW;<br>END</pre>
<p><b>IPC</b> is the p-code instruction pointer. It is a
segment-relative
byte pointer.<br>
<b>Proc_Num</b> is the number of the currently executing procedure in
this
task.<br>
<b>MP</b> points to the local activation record (MSCW) for the task, on
the stack.<br>
<b>SP</b> is the p-machine stack pointer.<br>
<b>SP_Low </b>is the lower bound of the stack for this task.<br>
<b>SP_Upr</b> is the upper bound of the stack for this task. Note that
each subsidiary task has its own private stack, allocated on the heap
when
the task is started. By default this stack is 200 words, but this can
be
specified when starting the task. Only the main task uses the system
stack.<br>
<b>Env</b> is a pointer to the task's E_Rec (from which you can find
the
the task's SIB).<br>
<b>TI_BIOResult</b> is used to save an I/O result that is local to the
task.<br>
<b>M_Depend</b> contains machine-dependent data maintained by the PME.
It is initialized as 0.</p>
<p><b>Prior</b> is the task priority. It's a number from 0 (lowest
priority)
to 255 (highest priority).<br>
<b>Wait_Q</b> is used when the task is in a waiting queue. It points to
the TIB of the next task in the list.<br>
<b>Hang_Ptr</b> is used when a task is blocked by a semaphore. It
points
to the semaphore (it's NIL if the task is not blocked).<br>
<b>Flags</b> are reserved for future use.<br>
<br>
<b>Main_Task</b> is TRUE for root ("parent") tasks, FALSE otherwise.<br>
<b>Start_MSCW</b> points to the MSCW of the routine that started this
task.</p>
<h4><br>
<a name="queue"></a>Queues and semaphores</h4>
<p>At any time, there is only one task running. All other tasks ready
to
run are placed in a waiting queue. When it's time to switch tasks, the
p-system fetches the appropriate task from the queue, switches to it,
and
places the current task back into the queue.</p>
<p>If necessary, tasks can be synchronized by using semaphores. A
semaphore
is a variable that can be "grabbed" by a task. If another task
attempts to grab the same semaphore it will hang, i.e. the task will be
suspended until the original task has "released" the semaphore.
At which point the hanging task will be able to grab the semaphore and
resume execution.</p>
<p>Actually, a semaphore can be grabbed an arbitrary number of times
before
it causes a task to hang. Similarly, a semaphore may be required to be
released several times before is actually frees the task(s) it has
hanged.
In most cases however, a "grab count" of one (mutual exclusion
semaphore, or "mutex") will do the job.</p>
<p>Each semaphore has an associated queue of tasks waiting for it,
similar
to the queue of tasks ready to run. Note that this queue may be empty
if
no task is waiting for this semaphore. Hanging and releasing a task
simply
means moving it from the semaphore queue to the "ready-to-run"
queue, or conversely.</p>
<p>To grab a semaphore, use the p-code <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#WAIT">WAIT</a>. It
decrements
the semaphore "grab count" or hangs the current task if the count
is already zero. Which means that the p-system places the current task
in the semaphore queue and switches to another task from the
"ready-to-run"
list.</p>
<p>To release a semaphore, use the p-code <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#SIGNAL">SIGNAL</a>.
It fetches the task at the head of the semaphore queue and places it in
the "ready-to-run" queue. A task switch will only occur if this
task has a higher priority than the current one. If the semaphore queue
is empty, the count is incremented and nothing else happens. The same
thing
happens if the semaphore count is negative: this allows to implement
semaphores
that must be signalled several times before hanged tasks can be
released.</p>
<p>You can also use the standard procedure <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ATTACH">ATTACH</a>
to automatically link a semaphore to a preset PME event. When this
event
occurs, the semaphore will be signaled. The standard procedures <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#QUIET">QUIET</a>
and <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#ENABLE">ENABLE</a> allow to globally disable or enable
event-attached
signalisation.</p>
<h4><br>
<a name="Concurency unit"></a>Concurrency unit</h4>
<p>The p-system comprises a compilation unit called CONCURENCY, which
implements
Pascal processes (a process is the Pascal word for a task). The unit
contains
3 procedures called START, STOP, and BLK_EXIT. The Pascal compiler
automatically
calls START in the initialisation code of a process, and STOP in its
exit
code. The compiler also calls BLK_EXIT in the exit code of a main
process.</p>
<p>These procedures make use of a global variable called Task_Info,
which
has the following structure:</p>
<pre>RECORD<br> Lock      : semaphore;<br> Task_Done : semaphore;<br> N_Tasks   : integer;<br>END</pre>
<p><b>Lock</b> is a semaphore used to ensure that only one task at a
time
will be able to modify Task_Info. <br>
<b>Task_Done</b> is a semaphore used to wait for the termination of
subsidiary
tasks.<br>
<b>N_Tasks </b>is the number of subsiduary tasks that have been
created
by START.</p>
<p><b>START</b></p>
<p>This procedure is called to create a new task. It reserves space on
the heap for the task's TIB, stack, and activation record, and then
executes
a WAIT p-code. This normally causes the p-system to switch to the new
process
(unless there is one with a higher priority pending). The new process
performs
its initialisation (i.e. copying its parameters) then executes a SIGNAL
to return to START, which in turn returns to its caller.</p>
<p><b>STOP </b></p>
<p>This procedure records the termination of a task. It decrements
Task_Info.N_Tasks
and signals Task_Info.Task_Done. It then creates a dummy semaphore and
waits for it, which causes a permanent task switch for the terminated
process.</p>
<p><b>BLK_EXIT</b></p>
<p>This procedure is called by the main tasks exit code and waits for
termination
of all subsidiary processes. It waits for Task_Info.Task_Done until
Task_Info.N_Tasks
becomes zero. In other words, it waits until each subsidiary task has
called
STOP.</p>
<h3><br>
<a name="Syscom area"></a>Syscom area</h3>
<p>The SYSCOM area is a memory location where the p-system stores
importants
variables that can be shared by the PME, the RSP, the BIOS and the OS,
as well as by your program. From the OS point of view, the SYSCOM area
can be considered as a Pascal packed record and is declared as such in
the interface of the KERNEL unit. </p>
<p>Low-level assembly routines on the other hand, must know the offset
of each variable with respect the the SYSCOM^ pointer that is defined
when
the system powers up. The problem here is that some of the variables
are
bytes, so their location will vary according to the byte sex. For
instance,
here are the offsets of the some keyboard special codes:</p>
<pre>Ctrl char  Little endian  Big endian<br>EOF          &gt;52            &gt;53   }<br>FLUSH        &gt;53            &gt;52   }<br>BREAK        &gt;54            &gt;55 }    <br>STOP/START   &gt;55            &gt;54 }<br>CHARMASK     &gt;5C            &gt;5D   }<br>ALPHALOCK    &gt;5D            &gt;5C   }<br>NOBREAK      &gt;3A            &gt;3B</pre>
<p>The pairs defined with braces are bytes in the same word. When the
byte
sex changes, the two bytes are flipped whithin the word.</p>
<h3><br>
<a name="File access"></a>File access</h3>
<p>We saw that the RSP/IO consider every unit as an array of blocks, an
illusion implemented by the BIOS. The OS takes things a level higher
and
introduces the concept of files. There can be two types of files:
standard
files that follow the Pascal conventions and are accessed with the GET
and PUT functions. And intereractive files that accept characters one
at
a time. From the OS point of view, both types of files share a common
structure
called the File Information Block, or FIB.</p>
<h4>Structure of a FIB</h4>
<pre>FIB = RECORD<br>       FWindow: Window_P;<br>       FEOF, FEOLN: Boolean;<br>       FState: (FJanW, FNeedChar, FGotChar);<br>       FRecSize: integer;<br>       FLock: semaphore;<br>       CASE FIsOPen: Boolean OF<br>        true: (FIsBlkd: Boolean;<br>               FUNIT: UNITNUM;<br>               FVID: VID;<br>               FRptCnt: integer;<br>               FMaxBlk: integer;<br>               FModified: Boolean;<br>               FHeader: DirEntry;<br>               CASE FSoftBuf: Boolean of<br>                true: (FNxtByte: integer;<br>                       FMaxByte: integer;<br>                       FBufChngd: Boolean;<br>                       FBuffer: PACKED&nbsp;ARRAY[0..FBlkSize] OF&nbsp;CHAR<br>                       )<br>               )</pre>
<p><b>FWindow</b> points to the current character in the file.<br>
<b>FEOF</b> is the end-of-file flag.<br>
<b>FEOLN</b> is the end-of-line flag.<br>
<b>FState</b> is the file type: FJanW is the standard Pascal type
(Jensen
&amp; Wirth), FNeedChar is an interactive file waiting for a character,
FGotChar is an interactive file with a character.<br>
<b>FRecSize </b>is the size of a record, in bytes. It is 0 for
unentered
files, -1 for interactive and text files.<br>
<b>FLock </b>is a semaphore used to ensure that only one process at a
time
can access a file.<br>
<b>FIsOpen </b>is true when the file is opened, which makes more
fields
relevant:</p>
<ul>
  <p><b>FIsBlkd </b>is true if the file resides on a storage device.<br>
  <b>FVID </b>is the number of the volume.<br>
  <b>FRepCnt </b>is the number of time the window value is valid
before another
GET is needed.<br>
  <b>FNxtBlk </b>is the next relative block to access.<br>
  <b>FMaxBlk </b>is the maximum number of blocks that can be accessed.<br>
  <b>FModified </b>is true if the file was modified and the last
access date
should be modified.<br>
  <b>FHeader </b>is a copy of the file's directory entry.<br>
  <b>FSoftBuf </b>is true if soft-buffered I/O is used, which is the
case
for all files on storage devices, except unentered files. If it is
true,
yet another set of fields become relevant:</p>
  <ul>
    <p><b>FNxtByte </b>is the next byte<br>
    <b>FMaxByte </b>is the last byte. These two are used for buffer
management.<br>
    <b>FBufChanged </b>is true if the buffer was modified and needs to
be saved.<br>
    <b>FBuffer </b>is of course the soft buffer itself.</p>
  </ul>
</ul>
<h4>Disk directory</h4>
<p>On a disk or another storage device is a directory, which is nothing
more than an array of 78 directory record. The first record (number 0)
defines the directory itself, the others entries define files.</p>
<p>The structure of the directory record is:</p>
<table border="1">
  <tbody>
    <tr>
      <td colspan="4">DFirstBlk</td>
    </tr>
    <tr>
      <td colspan="4">DLastBlk</td>
    </tr>
    <tr>
      <td width="70%">-</td>
      <td colspan="3" width="100%">DFKind</td>
    </tr>
    <tr>
      <td width="60%">Lenght (7)</td>
      <td colspan="3" width="40%">D</td>
    </tr>
    <tr>
      <td width="40%">I</td>
      <td colspan="3">R</td>
    </tr>
    <tr>
      <td>N</td>
      <td colspan="3">A</td>
    </tr>
    <tr>
      <td>M</td>
      <td colspan="3">E</td>
    </tr>
    <tr>
      <td colspan="4">DeovBlk</td>
    </tr>
    <tr>
      <td colspan="4">DNumFiles </td>
    </tr>
    <tr>
      <td colspan="4">DLoadTime</td>
    </tr>
    <tr>
      <td>DLastBoot<br>
(Year)</td>
      <td>DLastBoot <br>
(Month) </td>
      <td colspan="2">DLastBoot<br>
(Day) </td>
    </tr>
  </tbody>
</table>
<p><br>
The directory entries for files look like:</p>
<table border="1">
  <tbody>
    <tr>
      <td colspan="4">DFirstBlk</td>
    </tr>
    <tr>
      <td colspan="4">DLastBlk</td>
    </tr>
    <tr>
      <td width="70%">StatusBit</td>
      <td colspan="3" width="100%">DFKind</td>
    </tr>
    <tr>
      <td width="60%">Length (15) </td>
      <td colspan="3" width="100%">N</td>
    </tr>
    <tr>
      <td width="40%">A</td>
      <td colspan="3">M</td>
    </tr>
    <tr>
      <td width="40%">E</td>
      <td colspan="3">_</td>
    </tr>
    <tr>
      <td width="40%">O</td>
      <td colspan="3">F</td>
    </tr>
    <tr>
      <td width="40%">_</td>
      <td colspan="3">T</td>
    </tr>
    <tr>
      <td width="40%">H</td>
      <td colspan="3">E</td>
    </tr>
    <tr>
      <td width="40%">F</td>
      <td colspan="3">I</td>
    </tr>
    <tr>
      <td width="40%">L</td>
      <td colspan="3">E</td>
    </tr>
    <tr>
      <td colspan="4">DLastByte</td>
    </tr>
    <tr>
      <td>DAccess<br>
(Year)</td>
      <td>DAccess <br>
(Month)</td>
      <td colspan="2">DAccess <br>
(Day)</td>
    </tr>
  </tbody>
</table>
<h2>
<hr width="100%"><a name="File_format"></a>File formats</h2>
<p>This section describes the file formats used by the p-system.</p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Text%20file">Text files</a></p>
<p><b>Code files<br>
</b><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20dict">_Segment dictionary<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20header">_Segment header<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Proc%20dict">_Procedure dictionary<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Cte%20pool">_Constant pool<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Reloc%20list">_Relocation list<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20ref%20list">_Segment reference list<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Linker%20info">_Linker information</a></p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Assembly%20files">Assembly files</a></p>
<h3><a name="Text file"></a>Text files</h3>
<p>A text file should only contain ASCII characters. It starts with a
2-block
header that is used by the Screen Oriented Editor. If any other program
uses a text file, the OS ignores the header. When a new file is
created,
its header blocks are filled with zeros. </p>
<p>Text files always have an even number of block (so the smallest text
file is 4 blocks long, including the header). Each pair of blocks makes
up a page. Text does not wrap from one page to the next, if necessary
the
end of the page is filled with zeros.</p>
<p>Each page contains lines terminated by &lt;return&gt; (ascii
&gt;0D).
Optionally, if a line starts with a number of spaces, these can be
compressed
to save disk space. In this case, the line will start with the blank
compression
code (ascii &gt;10), followed by the number of spaces plus 32.</p>
<p>If you want to access text files from Pascal programs, use READ,
READLN,
WRITE and WRITELN, although GET&nbsp;and PUT&nbsp;also work and follow
the Jansen&amp;Wirth rules for text files.</p>
<h3><br>
<a name="Code file"></a>Code files</h3>
<p>Code files contain programs, or independently compiled chunks of
programs
called UNITs. These can contain both p-code and assembly language. In
addition,
the code file contains a lot of information on the code it carries, how
to link the various units, etc. </p>
<p>All in all, the structure of a code file is quite complex. It
consists
in a segment dictionary, and a series of <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Code%20segments">code
segments</a>. To make things worse, the structure of a code segment
varies
slightly between p-code and assembly segments.</p>
<h4><a name="Seg dict"></a>Segment dictionary</h4>
<p>The first block in a code file is the segment dictionary. It can
describe
upto 16 of the segments that are part of the file. If there are more
than
16 segments, extra blocks can be added to the dictionary. These extra
blocks
will be interspersed with the segments within the code file. Each block
contains a link to the following block, so that the chain can be
travelled.</p>
<p>A dictionary block basically consists in 6 arrays, which each upto
16
entries:</p>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Disk%20info">Disk info</a></li>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Segment%20names">Segment names</a></li>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20misc%20info">Miscellaneous segment info</a></li>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#interface%20text">Pointers to interface text</a></li>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Segment%20info">Segment information</a></li>
<li><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#segment%20familly">Segment familly</a></li>
<p>Followed by some <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Dictionary%20info">dictionary info</a>.</p>
<p>Lets examine these arrays in detail:</p>
<h5><a name="Disk info"></a>Disk info</h5>
<pre>Seg_Dict = RECORD<br>           Disk_Info: ARRAY[0..15] OF<br>            RECORD<br>             Code_Addr: integer;<br>             Code_Leng: integer;<br>            END</pre>
<p><b>Code_Address</b> is the block where the segments starts, relative
to the beginning of the code file. Thus, segments always start on a
block
boundary.<br>
<b>Code_Length</b> is the number of words in the segment, including the
relocation list, but not the reference list.<br>
All unused entries in this array will be zeros.</p>
<h5><br>
<a name="Segment names"></a>Segment names</h5>
<pre>          Seg_Name: ARRAY[0..15] OF<br>                     PACKED ARRAY[0..7] OF&nbsp;CHAR;</pre>
<p>These are the segment names, upto seven characters in length
(truncated
if necessary). Unused entries are filled with spaces.</p>
<h5><br>
<a name="Seg misc info"></a>Misc segment info</h5>
<pre>          Seg_Misc: ARRAY[0..15] OF<br>           PACKED&nbsp;RECORD<br>            Seg_Type: Seg_Types;<br>            Filler: 0..31<br>            Has_Link_Info: Boolean;<br>            Relocatable: Boolean;<br>           END</pre>
<pre> Seg_Types=(No_Seg, Prog_Seg, Unit_Seg, Proc_Seg, Seprt_Seg);</pre>
<p><b>Seg_type</b> is the segment type. It will be No_Seg if this
directory
entry is empty (e.g.if there are less than 16 segments). Prog_Seg
indicates
the outer segment of a program, Unit_Seg the outer segment of a
separately
compiled unit. Proc_Seg segments contain procedures belonging to a
program
or unit. Seprt_Seg segments contain assembly language.<br>
<b>Has_Link_Info</b> indicates that the segment needs to be linked. The
necessary linker information is included whithin the segment, starting
on the next block boundary after the reference list. <br>
<b>Relocatable</b> indicates whether the segment is dynamically
relocatable.If
it is, it can be loaded anywhere in the code pool, and moved around if
necessary. This is always the case for p-code segments. By contrast,
statically
relocatable segments will be loaded on the OS heap and locked there
throughout
their existence. Unless special care has been taken in writing them,
all
assembly segments are statically relocatable.<br>
<b>Filler</b> just reserves the remaining 5 bits in the packed record
for
future extension.</p>
<h5><br>
<a name="interface text"></a>Pointers to interface text</h5>
<pre>        Seg_Text: ARRAY[0..15] OF integers;</pre>
<p>This array contains the number of the block where the segment
interface
(in plain text) begins. The interface can be anywhere whithin the
segment,
provided its starts on a block boundary. It's basically a chunk of text
file and thus follows the text format, except that the number of blocks
does not need to be even. Its size is specified in the Seg_Familly
array.
Note that only unit segments have an interface section, all other
segments
will have zero in this array.</p>
<h5><a name="Segment info"></a>Segment info</h5>
<pre>        Seg_Info: ARRAY[0..15] OF<br>         PACKED&nbsp;RECORD<br>          Seg_Num: 0..255;<br>          M_Type: M_Types;<br>          Filler: 0..1;<br>          Major_Version: Versions;<br>         END</pre>
<pre> M_Types = (M_Pseudo, M_6809, M_PDP_11, M_8080, M_Z_80, M_GA_440, M_6502, M_6800<br>            M_9900, M_8086, M_Z8000, M_68000, M_HP87);</pre>
<pre> Versions = (Unknown, I, II, II_1, III, IV, V, VI, VII);</pre>
<p><b>Seg_Num</b>, surprisingly enough, is the segment number, in the
range
0 to 255.<br>
<b>M_Type</b> define the language the segment contains. If it's p-code,
the type will be M_Pseudo, and the type of p-machine will be indicated
in Major_Version. If the segment contains assembly language, the
processor
for which it was written is indicated here. <br>
<b>Major_Version</b> indicates which version of the p-machine the
p-code
was written for. So p-code is not that portable, after all...</p>
<h5><br>
<a name="segment familly"></a>Segment family</h5>
<pre>        Seg_Famly: ARRAY[0..15] OF<br>         RECORD<br>          CASE Seg_Types OF<br>          Prog_Seg, Unit_Seg:<br>           (Data_Size: integer;<br>            Seg_Refs: integer;<br>            Max_Seg_Num: integer;<br>            Text_Size: integer);<br>&nbsp;          Proc_Seg, Seprt_Seg:<br>            (Prog_Name: PACKED ARRAY[0..7] OF&nbsp;CHARS);<br>          END</pre>
<p>This array contains information that depends on the segment type.
For
program and unit segments, we have:<br>
<b>Data_Size</b> is the number of words in this segment's base data
segment.<br>
<b>Ref_Size</b> is the number of words in the segment's reference list.<br>
<b>Max_Seg_Num</b> is the highest segment number that was assigned
within
this compilation unit (regardless of whether the referenced segments
are
part of the code file or not).<br>
<b>Text_Size</b>, as we just saw, is the number of words in the
interface
section of a unit segment. For program segments this entry is zero.</p>
<p>Procedure segments and assembly language segment have only one field
here:<br>
<b>Prog_Name</b> is the name of their parent unit (truncated to 8
characters
if necessary). If it is unknown, which will generally be the case for
assembly
segments, this entry is filled with spaces.</p>
<h5><br>
<a name="Dictionary info"></a>Dictionary info</h5>
<p>After the 6 arrays are a few variables that contain dictionary
related
info.</p>
<pre>        Next_Dict: integer;<br>        Filler: ARRAY[1..2] OF integer;<br>        Checksum: integer;<br>        Ped_Block;<br>        Ped_Block_Count;<br>        Part_Number: RECORD A, B: integer; END<br>        Copy_Note: string[77];<br>        Dict_Byte_Sex: integer;<br>    END {of Seg_Dict}</pre>
<p><b>Next_Dict</b> is the number of the next dictionary block whithin
the file, if any. If there are no more blocks, it is zero.<br>
<b>Part_Number</b> is an arbitrary number for the program, as defined
by
its programmer.<br>
<b>Copy_Note</b> contains an optional copyright string.<br>
<b>Dict_Byte_Sex</b> always contains one. According to the machine on
which
the file was created, it will be coded either as &gt;0001 or as
&gt;0100.
This allows the system to determine the byte sex of the dictionary.<br>
<b>Checksum</b>, <b>Ped_Block</b> and <b>Ped_Block_Count</b> are used
by
an utility called QUICKSTART, that does not come with the TI-99/4A
p-code
system. For this reason, it is not described here.<br>
<b>Filler </b>reserves the last words in the block for futur use.<br>
</p>
<p>And if you think all this is complicated, wait till we take a look
at
the structure of a code segment...</p>
<h4><br>
<a name="Code segments"></a>Code segments</h4>
<li>Code segments can contain upto 255 routines, numbered from 1 to
255.
Within the segment is a procedure dictionary which holds pointers to
all
the procedures in the segment. </li>
<li>Constants embedded within p-code are actually placed in a separate
area in the segment, so that bytes can be flipped if the byte sex of
the
target machine is different from that of the machine the file was
created
on. </li>
<li>Segments also contain a relocation list containing the addresses of
the words that should be patched when the segment is moved from one
area
of memory to another. </li>
<li>Segments are assigned a name (8 characters long) and a number at
compilation
time. The name is used by the OS to stitch together the various
compilation
units referenced by a program. The number is used to reference the
segment
at run time, as described <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#E_Rec">above</a>.</li>
<li>Finally, a segment can also contain informations for linking it
with
other segments.</li>
<p>By order of appearance, here are the sections that may be contained
within a code segment (many are optional):</p>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20header">Segment header<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Proc%20dict">Procedure dictionary<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Cte%20pool">Constant pool<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Reloc%20list">Relocation list<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Seg%20ref%20list">Segment reference list<br>
</a><a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#Linker%20info">Linker information</a></p>
<h4><br>
<a name="Seg header"></a>Segment header</h4>
<p>Each segment starts with a mandatory header containing pointers to
the
various tables, and some segment-related info:</p>
<pre>Proc_Dic: integer;<br>Reloc_List: integer;<br>Seg_Name: PACKED ARRAY[1..8] OF&nbsp;CHAR;<br>Byte_Sex: integer;<br>Cte_Pool: integer;<br>Real_Size: integer;<br>Part_Number: RECORD A, B: integer; END</pre>
<p><b>Proc_Dic</b> is a pointer to the procedure dictionary. It's an
offset
in words from the start of the segment.<br>
<b>Reloc_List</b> is a pointer to the relocation list. Zero if there is
no relocation list.<br>
<b>Seg_Name</b> is the name of the segment.<br>
<b>Byte_Sex</b> is always 1. If the machine that loads the segment has
a different byte sex than the one which wrote it, Byte_Sex will be read
at 256 (&gt;0100). This lets the OS know that bytes should be flipped
whithin
this segment. Of course, p-code is byte-sex independent, but constants
embedded within the code are not and their bytes may need to be
flipped.
So are the various pointers in this header and in the procedure
dictionary.<br>
<b>Cte_Pool</b> is a pointer to the constant pool. It can be zero if
there
is no constant pool in this segment.<br>
<b>Real_Size</b> is the size of floating point numbers used by this
segment.<br>
<b>Part_Number</b> is a record of two integers reserved for future use
(e.g. to hold a version number).</p>
<h4><br>
<a name="Proc dict"></a>Procedure dictionary</h4>
<p>The procedure dictionary is nothing more than a list of pointers to
each and every procedure in the segment. The list grows downwards, from
the address pointed at by Proc_Dic. In other words, procedure numbers
can
be considered as negative indices whithin the dictionary. The top word
in the dictionary (index 0, pointed at by Proc_Dic) is the number of
procedures
in the dictionary. There may be empty entries in the dictionary, whose
content is 0. These correspond to procedures that were declared as
EXTERNAL
or FORWARD routines.</p>
<pre>+------------+                   +-----------+<br>| # of procs |                   | exit code |&lt;-,<br>+------------+ &lt;-- Proc_Dic      |           |  |<br>| Proc #1    |                   :           :  |<br>+------------+                   |   code    |  |<br>| Proc #2    |                   +-----------+  |<br>+------------+                   | Data_Size |  |<br>| Proc #3 ---|-----------------&gt; +-----------+  |<br>+------------+                   |&nbsp;Exit_IC --|--'<br>| Proc #4    |                   +-----------+<br>+------------+<br>|    etc     |</pre>
<p>The procedures pointers are word offset relative to the start of the
segment, just like Proc_Dic itself. Which means that they may need to
be
flipped if byte sexes do not match.</p>
<p>Procedures are aligned on word boundaries and always begins with two
words.</p>
<pre>Exit_IC: integer;<br>Data_Size: integer;</pre>
<p>The pointer in the procedure dictionary points at Data_Size, which
is
immediately followed by the executable code, whether p-code, assembly
or
a mixture of both. </p>
<p>Data_Size is the number of words of local space that the procedure
needs
for its variables. It does not include the calling parameters that are
assumed to be already on stack when the procedure is called. No local
space
is reserved for pure assembly routines. For mixed language routines,
Data_Size
is negative if the first instruction is in assembly.</p>
<p>Exit_IC points to the code that must be executed when a p-code
procedure
is terminated. It is a offset in bytes (not words!) from the start of
the
segment. Exit_IC is undefined for assembly language routines, and for
mixed
procedures that begin with assembly. For this reason, compilers that
produce
mixed code procedures generally start them with at least one p-code
(e.g.
NAT, or NOP and NAT), so that Exit_IC will be defined.</p>
<h4><br>
<a name="Cte pool"></a>Constant pool</h4>
<p>Multi-word contants embeded in p-code are pulled out by the compiler
and placed in a dedicated area, just after the last procedure in the
segment.
The area is pointed at by Cte_Pool. All p-code instuctions that use
constants
refer to them as offsets from the bottom of the code pool. This
strategy
allows p-code to be completely byte-sex independent. Of course, the
code
pool is not and its bytes will need to be flipped if the machine on
which
the program is loaded does not have the same sex that the machine on
which
the program was written.</p>
<p>Real numbers in floating point format represent a special case.
These
are coded in one of the two canonical format described above. The word
Real_Size in the segment header indicates the <a href="http://www.unige.ch/medecine/nouspikel/ti99/psystem.htm#real%20numbers">real
number format</a> used by the machine that created the program (this
word
is valid even if no real number was actually defined). It will be 32
for
the 3-words format (32 bits) and 64 for the 3-to-6 words format. Real
numbers
are clustered together in a separate region of the constant pool, which
is pointed at by the very first word in the pool. The first word in the
real sub-pool is the number of real constants that follow.</p>
<p>Example:</p>
<pre>| Proc dict  |<br>+------------+<br>|  Constant  |<br>:    ...     :<br>|  Constant  |<br>+------------+<br>|    Real    |<br>:    ...     :<br>|    Real    |<br>+------------+<br>| # of reals |<br>+------------+&lt;-,<br>|  Constant  |  |<br>:    ...     :  |<br>|  Constant  |  |<br>+------------+  |<br>|  Sub-pool -|--'<br>+------------+ &lt;--- Cte_Pool<br>| Last proc  |</pre>
<h4><br>
<a name="Reloc list"></a>Relocation list</h4>
<p>The relocation list is generally placed after the procedure
dictionary.
It is pointed at by the Rel_List word in the segment header. It
contains
a list of all addresses that need to be patched when the segment is
loaded
in memory, or moved around. Note that only assembly needs a relocation
list, since p-code is address-independent.</p>
<p>The relocation list is made of any number of sublists. Each sublist
consists in a header that specifies the size of the sublist and the
type
of relocation required, followed by a list of pointers to the addresses
that need to be patched. Here is the structure of this header:</p>
<pre>List_Header = PACKED RECORD<br>               List_Size: integer;<br>               Data_Seg_Num: 0..255;<br>               Reloc_Type: Loc_Types;<br>              END</pre>
<pre>Loc_Types = (Reloc_End, Seg_Rel, Base_Rel, Interp_Rel, Proc_Rel);</pre>
<p><b>List_Size</b> is the number of pointers that follow the header in
the sublist, i.e. the number of addresses to patch.<br>
<b>Data_Seg_Num</b> is only used by sublists of type Base_Rel and is
zero
for other types. It contains the local number of the data segment to
which
the pointers in the sublist are relative. Its value is normally
assigned
by the Linker.<br>
<b>Reloc_Type</b> specifies the type of relocation requires. Reloc_End
(value = 0) serves as a terminator to indicated that there are no more
sublists in the relocation list. The Proc_Rel type (procedure-relative)
is produced by the Assembler but will be changed to Seg_Rel
(segment-relative)
by the Linker, so you should never encounter it in a linked code file.</p>
<p>Example:</p>
<ul>
  <pre>+------------+--------------+<br>| Reloc_Type | Data_Seg_Num |<br>+------------+--------------+ &lt;--- Reloc_List<br>| List_Size                 |<br>+---------------------------+<br>| Pointer                   |<br>:  ...                      :<br>| Pointer                   |<br>+------------+--------------+<br>| Reloc_Type | Data_Seg_Num |<br>+------------+--------------+<br>| List_Size                 |<br>+---------------------------+<br>| Pointer                   |<br>:   ...                     :<br>| Pointer                   |<br>+------------+--------------+<br>|     0      |      0       |<br>+------------+--------------+</pre>
</ul>
<p>Note that the relocation list grows from top to bottom: Reloc_List
points
at the sublist with the highest offset in the segment, whereas the
sublist
with a Reloc_Type of zero (Reloc_End) is at the bottom.</p>
<h4><br>
<a name="Seg ref list"></a>Segment reference list</h4>
<p>The segment reference list is only needed by Unit segments. It is
necessary
because segment numbers are assigned arbitrarily by the compiler within
a compilation unit. The segment reference list associates these
unit-specific
numbers the with the corresponding segment names, so that the OS can
set
up the proper E_Vect and E_Rec structures when building up the run-time
environment. Once this is done, the segment reference list is
discarded,
so it won't use up any memory at execution time.</p>
<p>The list is placed at the end of the segment, after the relocation
list
(if any). Its location can be deduced by using the field Code_Length in
the segment dictionary as an offset from the beginning of the segment.
The size of the list (in words ) is also found in the segment
dictionary,
in the word Ref_Size.</p>
<p>The list consists simply in a series of records with the following
structure:</p>
<pre>Seg_Reg = PACKED RECORD<br>           Seg_Name: PACKED ARRAY[0..7] OF&nbsp;CHAR;<br>           Seg_Num: 0..255;<br>           Filler: 0..255;<br>          END</pre>
<p><b>Seg_Name</b> is the 8-character segment name.<br>
<b>Seg_Num</b> is the number this segment was assigned in this
compilation
unit.<br>
<b>Filler</b> is reserved for future extensions.</p>
<p>The end of the list is marked by a record with a Seg_Name consisting
in 8 spaces, and a Seg_Num of zero. It could also be calculated from
the
Ref_Size value (5 words per record).</p>
<p>Dummy records with Seg_Name "***" are generated so that the
OS&nbsp;can execute the initiation and termination code of a unit. When
loading a program, the OS creates a list of all units that contain such
a record, finishing with the main program. It then calls procedure
number
1 in the first unit of the list. Procedure number 1 is reserved for the
initialization/termination section of a unit. When done with
initialization,
the first unit calls the next one, which calls the next, etc, until the
last unit calls the main program. When the program terminates, the ***
list is popped and the same procedures are returned to, thereby
travelling
the chain back in reverse order.</p>
<h4><br>
<a name="Linker info"></a>Linker informations</h4>
<p>Code files produced by the Assembler and the Compiler may contain
some
information for the Linker to use in linking assembly language segments
to p-code segments. Segments produced by the Assembler always have
linker
information, segments produced by the Compiler only have some if they
contain
EXTERNAL routines. The Has_Linker_Info flag in the segment dictionary
indicates
whether a segment has such information or not.</p>
<p>Linker information is always at the end of the segment, starting on
a block boundary after the segment reference list (if any). There is no
pointer to it in the segment header, but its address can be calculated
from the segment entries in the segment dictionary: <br>
<tt>Code_Addr + ((Code_Length + Seg_Refs + 255) / 256)</tt>.</p>
<p>Linker information is a series of 8-word records, whose contents
depends
on the type of linking required. Records are padded with zeros if less
than 8 words are actually used. Some records are followed by a list of
pointers whithin the segment. All records can be defined with a single
Pascal structure, even though they only share the common Name and
LI_Type
fields.</p>
<pre>LI_Types = (EOF_Mark, Glob_Ref, Publ_Ref, Priv_Ref, Const_Ref,<br>            Glob_Def, Publ_Def, Const_Def, Ext_Proc, Ext_Func, Sep_Proc, Sep_Func);</pre>
<pre>LI_Entry = RECORD<br>            Name: PACKED ARRAY[0..7] OF CHARS;<br>            CASE LI_Type: LI_Types OF<br>             Glob_Ref, Publ_Ref, Const_Ref:<br>               (Format: (Word, Byte, Big);<br>                N_Refs: integer);<br>             Priv_Ref:<br>               (Format: (Word, Byte, Big);<br>                NRefs: integer;<br>                N_Words: integer);<br>             Ext_Proc, Ext_Func:<br>               (Src_Proc: integer;<br>                N_Params: integer);<br>             Sep_Proc, Sep_Func:<br>               (Sec_Proc: integer;<br>                N_Params: integer;<br>                Kool_bit: boolean);<br>             Glob_Def:<br>               (Home_Proc: integer;<br>                IC_Offset: integer);<br>             Publ_Def:<br>               (Base_Offset: integer;<br>                Pub_Data_Seg: integer);<br>             Const_Def:<br>               (Const_Val: integer);<br>            END;</pre>
<pre>Ptr_List:&nbsp;ARRAY[0..ceiling(N_Refs/8)] OF<br>           ARRAY[0..7} OF&nbsp;integer; </pre>
<p>Ok, let's take these one at a time. Remember that they all have a
Name
field that hold the name of the identifier, and a LI_Type field that
indicated
the type of linking required.</p>
<p><b>Glob_Ref</b> is used to link identifiers between assembly
routines.</p>
<pre> Glob_Ref:<br>  (Format: (Word, Byte, Big);<br>   N_Refs: integer);</pre>
<p><b>Name </b>is the name of the identifier (a.k.a. label).<br>
<b>Format </b>is always 0 (i.e. "word").<br>
<b>N_Refs</b> is the number of references in the list that follows the
record.</p>
<p><b>Ptr_List:</b> The reference list comes by chunks of 8 words. For
Glob_Ref, the Linker will add the final segment offset to each of the
words
pointed at by the reference list. The offset could be in words or in
bytes
depending on the assembly language used.</p>
<p><br>
<b>Publ_Ref</b> is used to link a label in an assembly routine to a
variable
in a compilation unit (compiled into p-code).</p>
<pre> Publ_Ref:<br>  (Format: (Word, Byte, Big);<br>   N_Refs: integer);</pre>
<p><b>Name </b>is both the name of the label and the name of the
variable
in the compilation unit.<br>
<b>Format </b>is always "word".<br>
<b>N_Refs</b> is the number of references in the list that follows the
record.</p>
<p>The linker will add the offset of the variable to all words pointed
at by the reference list.</p>
<p><br>
<b>Const_Ref</b> is used to link a label in an assembly routine to a
constant
defined in a compilation unit.</p>
<pre> Const_Ref:<br>  (Format: (Word, Byte, Big);<br>   N_Refs: integer);</pre>
<p><b>Name </b>is the name of the label, and the name of the constant.<br>
<b>Format </b>can be "word" (0) or "byte" (1).<br>
<b>N_Refs</b> is the number of references in the list that follows the
record.</p>
<p>The linker will place the constant byte or word at all locations
specified
in the reference list.</p>
<p><br>
<b>Priv_Ref</b> is used to allocate space is the global data segment.</p>
<pre> Priv_Ref:<br>  (Format: (Word, Byte, Big);<br>   NRefs: integer;<br>   N_Words: integer)</pre>
<p><b>Format </b>is always "word".<br>
<b>N_Words</b> is the number of words to allocate.<br>
<b>N_Refs</b> is the number of references in the list that follows the
record.</p>
<p>The Linker will add the offset of the beginning of the allocated
area
to each word pointed at by the reference list.</p>
<p><br>
<b>Ext_Proc</b> and <b>Ext_Func</b> are generated by the Compiler to
reference
EXTERNAL routines. They are not followed with a pointer list.</p>
<pre> Ext_Proc, Ext_Func:<br>  (Src_Proc: integer;<br>   N_Params: integer);</pre>
<p><b>Name </b>is the name of the routine.<br>
<b>Src_Proc</b> is the number assigned to the routine.<br>
<b>N_Params</b> is the number of words used for parameter passing.</p>
<p><br>
<b>Sep_Proc</b> and <b>Sep_Func</b> are generated by the Assembler to
declare
routines. They are not followed with a pointer list.</p>
<pre> Sep_Proc, Sep_Func:<br>  (Sec_Proc: integer;<br>   N_Params: integer;<br>   Kool_bit: boolean);</pre>
<p><b>Name </b>is the name of the routine.<br>
<b>Src_Proc</b> is the number assigned to the routine.<br>
<b>N_Params</b> is the number of words used for parameter passing.<br>
<b>Kool_Bit</b> is true if the routine is relocatable ( created with <tt>.RELPROC</tt>
and <tt>.RELFUNC</tt>) and false otherwise.</p>
<p><br>
<b>Glob_Def</b> is generated by the Assembler to declare a global
identifier
(with <tt>.DEF</tt>, <tt>.PROC</tt>, <tt>.FUNC</tt>, <tt>.RELPROC</tt>
or <tt>.RELFUNC</tt>). There is no pointer list.</p>
<pre> Glob_Def:<br>  (Home_Proc: integer;<br>   IC_Offset: integer);</pre>
<p><b>Name </b>is an identifier valid within the segment, that can be
referenced
by other routines from the same segment.<br>
<b>Home_Proc</b> is the number of the routine in which the identifier
is
defined.<br>
<b>IC_Offset</b> is the offset in bytes of the label whithin the
routine
that contains it.</p>
<p><br>
<b>Publ_Def</b> is generated by the Compiler to declare a global
variable
that should be visible to <tt>EXTERNAL </tt>routines. It is not
followed
with a pointer list.</p>
<pre> Publ_Def:<br>  (Base_Offset: integer;<br>   Pub_Data_Seg: integer);</pre>
<p><b>Name </b>is the name of the variable.<br>
<b>Base_Offset</b> is the offset in words of the variable, from the
start
of the segment that contains it.<br>
<b>Pub_Data_Seg</b> is the local number of the data segment that
contains
the variable.</p>
<p><br>
<b>Const_Def</b> is generated by the Compiler to declare a global
constant
that should be visible to EXTERNAL routines. It does not have a pointer
list.</p>
<pre> Const_Def:<br>  (Const_Val: integer);</pre>
<p><b>Name </b>is the name of the constant.<br>
<b>Const_Val</b> is the value of the constant.</p>
<p><br>
<b>EOF_Mark</b> is a special type that marks the end of the linker
information
list. <b>Name </b>should be filled with spaces, the remainder of the
record,
as always, filled with zeros.<br>
</p>
<p>Note that not all segments can have every type of linker
information.
Compiler generated Prog_Seg and Unit_Seg can :</p>
<li>Refer to Ext_Proc and Ext_Func defined by assembly routines</li>
<li>Define Publ_Def and Const_Def for assembly segments to refer to</li>
<li>And of course, issue an EOF_Mark to mark the end of the list.</li>
<p>Assembly generated Seprt_Seg can:</p>
<li>Define Sep_Proc and Sep_Func for p-code segments to call</li>
<li>Define Glob_Def and refer to Glob_Ref, for assembly-to-assembly
linking</li>
<li>Refer to Publ_Ref and Const_Ref to link with p-code</li>
<li>Issue Priv_Ref to reserve space</li>
<li>Issue an EOF_Mark.</li>
<h3><br>
<a name="Assembly files"></a>Assembly files</h3>
<p>The structure of a pure assembly file, generated by the Assembler,
resembles
a lot the Compiler-generated code files described above. There are a
few
differences however.</p>
<p>Most importantly, each procedure has its own relocation list,
located
just after the body of the procedure. Since Exit_IC is not used by
assembly
routines, this word is used to point at the top of the relocation list
(remembers, it grows downwards). These relocation lists are the only
ones
in which the Proc_Rel relocation type can be used. The Linker will
convert
all the procedure's lists into a big segment's list, in which the
Proc_Rel
will be replaced with Seg_Rel.</p>
<p>For each procedure, the Data_Size word is &gt;FFFF, which is zero in
one's complement notation. It indicates 1) that no data space is
required,
2) that the first instruction in the routine is an assembly opcode.</p>
<p>Since the Assembler does not know the segment name, all routines
that
communicate with REFs and DEFs are assumed to be in the same segment.</p>
<p>And since assembly segments don't know what program or unit they are
linked to, the Prog_Name entry in the segment dictionary is left blank.
For the same reason, the Data_Seg_Num field in the List_Header record
of
Base_Rel sublists will contain zeros. The proper value will be filled
in
by the Linker. The Linker also updates the Relocatable bit in Seg_Misc
arrays according to what was supplied in the linker information section.</p>
<p>At linking time, it is also possible that the code bodies of
assembly
routines will be copied into one of the segments of the compilation
unit
they are linked to.</p>
<center>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/pcode.htm">Next page: the TI-99/4A p-code card</a></p>
</center>
<address><br>
Revision 1. 9/21/01 Ok to release.</address>
<address><br>
</address>
<center>
<p><a href="http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
<p>&nbsp; </p>


</body></html>